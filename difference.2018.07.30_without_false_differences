+-diff --git a/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clustering-tmp.xml b/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clustering-tmp.xml
+-index 710b97e..c9a99a8 100644
+---- a/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clustering-tmp.xml
+-+++ b/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clustering-tmp.xml
+-@@ -148,6 +148,7 @@ Available types of the data format:
+-   <parameter name="SparseClusterCut" type="float" value="0.0"/>
+-   <!--Minimum distance between sparsified pixel ( touching == sqrt(2)) -->
+-   <parameter name="SparseMinDistance" type="float" value="1"/>
+-+  <parameter name="SparseMinDistanceSquared" type="float" value="2"/>
+-   <!--Threshold in SNR for seed pixel contained in ZS data-->
+-   <parameter name="SparseSeedCut" type="float" value="0.0"/>
+-   <!--verbosity level of this processor ("DEBUG0-4,MESSAGE0-4,WARNING0-4,ERROR0-4,SILENT")-->
+-diff --git a/processors/include/EUTelProcessorClusterAnalysis.h b/processors/include/EUTelProcessorClusterAnalysis.h
+-index 5ad63a3..d585de0 100644
+---- a/processors/include/EUTelProcessorClusterAnalysis.h
+-+++ b/processors/include/EUTelProcessorClusterAnalysis.h
+-@@ -55,6 +55,7 @@ protected:
+-   int _nNoiseMaskClusters;
+-   int _nDeadColumnClusters;
+-   int _sectorWidth;
+-+  int _chipVersion;
+-   double _energy;
+-   EVENT::StringVec _chipID;
+-   EVENT::StringVec _irradiation;
+-@@ -79,10 +80,14 @@ private:
+-   int _nLayer;
+-   int _xPixel;
+-   int _yPixel;
+-+	int _sparseMinDistanceSquaredComparison;
+-   std::map<int,TH1I*> clusterWidthXHisto;
+-   std::map<int,TH1I*> clusterWidthYHisto;
+-   std::map<int,TH1I*> clusterSizeHisto;
+-   TH1I* timeStampHisto;
+-+  TH1I* GeneratedClustersHisto;
+-+  TH1I* MissingClusterHisto;
+-+  TH1I* HowManyClusterGeneratedFromOneCluster;
+-   TH2I* hotpixelHisto;
+-   TH2I* deadColumnHisto;
+-   TH2I* circularClusterHistos;
+-diff --git a/processors/src/EUTelProcessorClusterAnalysis.cc b/processors/src/EUTelProcessorClusterAnalysis.cc
+-index 0b37868..d8aae37 100644
+---- a/processors/src/EUTelProcessorClusterAnalysis.cc
+-+++ b/processors/src/EUTelProcessorClusterAnalysis.cc
+-@@ -58,7 +58,9 @@ EUTelProcessorClusterAnalysis::EUTelProcessorClusterAnalysis()
+-   _hotPixelCollectionName(""),
+-   _nLayer(0),
+-   _xPixel(),
+--  _yPixel()
+-+  _yPixel(),
+-+  _chipVersion(4),
+-+  _sparseMinDistanceSquaredComparison(1)
+- 
+-   {
+-     _description="Analysing cluster properties such as cluster shape and average cluster size.";
+-@@ -97,15 +99,27 @@ EUTelProcessorClusterAnalysis::EUTelProcessorClusterAnalysis()
+-                              _irradiation, _stringVecExample );
+-     registerOptionalParameter("Rate","Data taking rate",
+-                              _rate, static_cast< string > ( "" ) );
+-+  registerOptionalParameter("ChipVersion", "Chip Version",
+-+                            _chipVersion, static_cast<int>(4) );
+-     _isFirstEvent = true;
+-   }
+- 
+- void EUTelProcessorClusterAnalysis::init() {
+-   _nLayer = geo::gGeometry().nPlanes();
+-   const std::vector<int>& _planeID = geo::gGeometry().sensorIDsVec();
+-+cout<<"Here I am."<<endl;
+-+
+-+cout<<_dutID<<endl;
+-   for(int iz=0; iz < _nLayer ; iz++)
+- 	  if(_planeID[iz]==_dutID)
+- 		  _layerIndex = iz;
+-+  if (_chipVersion < 3)     _nSectors = 4;
+-+  else if (_chipVersion==3) _nSectors = 8;
+-+  else if (_chipVersion==5) _nSectors = 4;
+-+  else                      _nSectors = 1;
+-+cout<<"Here I am."<<endl;
+-+cout<<_chipVersion<<endl;
+-+cout<<_nSectors<<endl;
+-  
+-   //beware, sometimes dutID is 3, sometimes it is 6
+-   int iLayer = _dutID;
+-@@ -320,6 +334,138 @@ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
+- 					pix.push_back(Y[iPixel]);
+- 					pixVector.push_back(pix);
+- 				}
+-+
+-+				//This part is to analysis the effect of the distance square between the pixels in one cluste
+-+				if(true)
+-+				{		
+-+					bool samecluster(true);
+-+					int howmanyclustergeneratedfromonecluster(0);
+-+					int AllGeneratedPixel(0);
+-+					int AllMissingPixel(0);
+-+
+-+					//Cluster mycluster;
+-+			
+-+           				std::vector<EUTelGenericSparsePixel> hitPixelVec = sparseData.getPixels();
+-+
+-+				        std::vector<EUTelGenericSparsePixel> newlyAdded;
+-+
+-+					int firsthclustersize=hitPixelVec.size();
+-+			 	        //We now cluster those hits together
+-+            				while( !hitPixelVec.empty() )
+-+            				{
+-+
+-+	
+-+                				std::vector<EUTelGenericSparsePixel> cluCandidate;
+-+
+-+                				//First we need to take any pixel, so let's take the first one
+-+                				//Add it to the cluster as well as the newly added pixels
+-+                				newlyAdded.push_back( hitPixelVec.front() );
+-+                				//sparseCluster->push_back( &(hitPixelVec.front()) );
+-+                				cluCandidate.push_back( hitPixelVec.front() );
+-+                				//And remove it from the original collection
+-+                				hitPixelVec.erase( hitPixelVec.begin() );
+-+
+-+                				//Now process all newly added pixels, initially this is the just previously added one
+-+                				//but in the process of neighbour finding we continue to add new pixels
+-+                				while( !newlyAdded.empty() )
+-+                				{
+-+                    					bool newlyDone = true;
+-+                    					int  x1, x2, y1, y2, dX, dY;
+-+
+-+                    					//check against all pixels in the hitPixelVec
+-+                    					for( std::vector<EUTelGenericSparsePixel>::iterator hitVec = hitPixelVec.begin(); hitVec != hitPixelVec.end(); ++hitVec )
+-+                    					{
+-+      		                  				//get the relevant infos from the newly added pixel
+-+                	        				x1 = newlyAdded.front().getXCoord();
+-+                	        				y1 = newlyAdded.front().getYCoord();
+-+	
+-+                	        				//and the pixel we test against
+-+                	        				x2 = hitVec->getXCoord();
+-+                	        				y2 = hitVec->getYCoord();
+-+	
+-+                	        				dX = x1 - x2;
+-+                	        				dY = y1 - y2;
+-+                	        				int distance = dX*dX+dY*dY;
+-+                	        				//if they pass the spatial and temporal cuts, we add them
+-+	
+-+                	        				if( distance <= _sparseMinDistanceSquaredComparison )
+-+                	        				{
+-+                		            				//add them to the cluster as well as to the newly added ones
+-+                		           				newlyAdded.push_back( *hitVec );
+-+                		            				cluCandidate.push_back( *hitVec );
+-+                		          				//	sparseCluster->push_back( &(*hitVec) );
+-+                		            				//and remove it from the original collection
+-+                		            				hitPixelVec.erase( hitVec );
+-+                		            				//for the pixel we test there might be other neighbours, we still have to check
+-+                		            				newlyDone = false;
+-+                		            				break;
+-+                		        			}
+-+                		    			}
+-+
+-+       						        //if no neighbours are found, we can delete the pixel from the newly added
+-+					                //we tested against _ALL_ non cluster pixels, there are no other pixels
+-+ 					                //which could be neighbours
+-+                					if(newlyDone) 
+-+							{
+-+								newlyAdded.erase( newlyAdded.begin() );
+-+							}
+-+             					}
+-+
+-+						if(firsthclustersize!=cluCandidate.size())
+-+						{
+-+							samecluster=false;
+-+							howmanyclustergeneratedfromonecluster++;
+-+							AllGeneratedPixel+=cluCandidate.size();
+-+							GeneratedClustersHisto->Fill(cluCandidate.size());
+-+							//cout<<"I filled GeneratedClustersHisto with: "<<cluCandidate.size()<<endl;
+-+						}
+-+						/*
+-+						vector<int> X(clusterSize);
+-+						vector<int> Y(clusterSize);
+-+
+-+  						int iforX=0;
+-+                				while(!cluCandidate.empty())
+-+                				{
+-+							X[iforX]=cluCandidate.fornt()..getXCoord();
+-+							Y[iforX]=cluCandidate.fornt()..getYCoord();
+-+                    					cluCandidate.erase( cluCandidate.begin() );
+-+							iforX++;
+-+                				}
+-+
+-+						mycluster.set_values(clusterSize,X,Y);
+-+						*/
+-+
+-+					}
+-+			
+-+
+-+					if(!samecluster)
+-+					{
+-+						MissingClusterHisto->Fill(firsthclustersize);
+-+						HowManyClusterGeneratedFromOneCluster->Fill(howmanyclustergeneratedfromonecluster);
+-+						howmanyclustergeneratedfromonecluster=0;
+-+						AllMissingPixel=firsthclustersize;
+-+						//cout<<"I filled MissingClusterHisto with: "<<firsthclustersize<<endl;
+-+					}
+-+
+-+					//cout<<"I have done the "<<idetector<<"th cluster"<<endl;
+-+
+-+					if(AllGeneratedPixel!=AllMissingPixel)
+-+					{
+-+						cout<<"ERROR: AllMissingPixel!=AllMissingPixel"<<endl;
+-+						cout<<"AllMissingPixel: "<<AllMissingPixel<<endl;
+-+						cout<<"AllGeneratedPixel: "<<AllGeneratedPixel<<endl;
+-+					}
+-+					AllMissingPixel=0;
+-+					AllGeneratedPixel=0;
+-+				}
+-+
+-+
+-+				//The end of the part folr distance analysis
+-+
+-+
+-+
+-+
+-+
+- 				streamlog_out ( DEBUG5 ) << "This is a DEBUG output to see whether the program gets here. The number X[0] is " << X[0] << " and _sectorWidth is " << _sectorWidth << endl; 
+- 				//now, since all pixels are from the same sector, the sector number can be set.
+- 				int index = X[0]/_sectorWidth;
+-@@ -390,11 +536,14 @@ void EUTelProcessorClusterAnalysis::bookHistos()
+-       AIDAProcessor::tree(this)->mkdir(Form("Sector_%d",iSector));
+-       AIDAProcessor::tree(this)->cd(Form("Sector_%d",iSector));
+- 
+--      clusterWidthXHisto[iSector]  = new TH1I(Form("clusterWidthXHisto_%d",iSector),Form("Cluster width in X in sector %d;Cluster width X (pixel);a.u.",iSector),15,0.5,15.5);
+--      clusterWidthYHisto[iSector]  = new TH1I(Form("clusterWidthYHisto_%d",iSector),Form("Cluster width in Y in sector %d;Cluster width Y (pixel);a.u.",iSector),15,0.5,15.5);
+--      clusterSizeHisto[iSector]  = new TH1I(Form("clusterSizeHisto_%d",iSector),Form("Cluster size_%d;Cluster size (pixel);a.u.",iSector),20,0.5,20.5);
+-+      clusterWidthXHisto[iSector]  = new TH1I(Form("clusterWidthXHisto_%d",iSector),Form("Cluster width in X in sector %d;Cluster width X (pixel);a.u.",iSector),50,0.5,50.5);
+-+      clusterWidthYHisto[iSector]  = new TH1I(Form("clusterWidthYHisto_%d",iSector),Form("Cluster width in Y in sector %d;Cluster width Y (pixel);a.u.",iSector),50,0.5,50.5);
+-+      clusterSizeHisto[iSector]  = new TH1I(Form("clusterSizeHisto_%d",iSector),Form("Cluster size_%d;Cluster size (pixel);a.u.",iSector),200,0.5,200.5);
+-       clusterShapeHistoSector[iSector] = new TH1I(Form("clusterShapeHisto_%d",iSector),Form("Cluster shape (all rotations separately) Sector %d;Cluster shape ID;a.u.",iSector),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
+-       clusterShapeHistoGroupedSector[iSector] = new TH1I(Form("clusterShapeHistoGrouped_%d",iSector),Form("Cluster shape (all rotations treated together) Sector %d;Cluster shape ID;a.u.",iSector),symmetryGroups.size(),-0.5,symmetryGroups.size()-0.5);
+-+      GeneratedClustersHisto = new TH1I(Form("GeneratedClustersHisto"),Form("GeneratedClustersHisto;Cluster size (pixel);a.u."),200,0.5,200.5); 
+-+      MissingClusterHisto = new TH1I(Form("MissingClusterHisto"),Form("MissingClusterHisto;Cluster size (pixel);a.u."),200,0.5,200.5);
+-+      HowManyClusterGeneratedFromOneCluster = new TH1I(Form("HowManyClusterGeneratedFromOneCluster"),Form("HowManyClusterGeneratedFromOneCluster;Cluster size (pixel);a.u."),20,0.5,20.5);
+-     }
+-   streamlog_out ( DEBUG5 )  << "end of Booking histograms " << endl;
+- }
+diff --git a/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clusterAnalysis-tmp.xml b/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clusterAnalysis-tmp.xml
+index 7618721..fdd6caf 100644
+--- a/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clusterAnalysis-tmp.xml
++++ b/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clusterAnalysis-tmp.xml
+@@ -108,21 +108,6 @@
+   <!--Data taking rate-->
+   <parameter name="Rate" type="string" value="@Rate@"/>
+   <!--parameter name="Verbosity" type="string" value="DEBUG"/-->
+-  <!--I_Need_Distance_Square_Analysis-->
+-  <parameter name="I_Need_Distance_Square_Analysis" type="bool" value="false"/>
+-  <!--I_Need_Empty_Middle_Analysis-->
+-  <parameter name="I_Need_Empty_Middle_Analysis" type="bool" value="false"/>
+-  <!--I_Need_Plote_Size_Cut_Hitmap-->
+-  <parameter name="I_Need_Plote_Size_Cut_Hitmap" type="bool" value="false"/>
+-  <!--I_Need_Plot_Example_Events-->
+-  <parameter name="I_Need_Plot_Example_Events" type="bool" value="false"/>
+-  <!--I_Need_Fireing_Probability_Analysis-->
+-  <parameter name="I_Need_Fireing_Probability_Analysis" type="bool" value="true"/>
+-  <!--I_Need_How_Many_Pixels_Fire_In_An_Event-->
+-  <parameter name="I_Need_How_Many_Pixels_Fire_In_An_Event" type="bool" value="true"/>
+-  <!--_sparseMinDistanceSquaredComparison-->
+-  <parameter name="_sparseMinDistanceSquaredComparison" type="int" value="1"/>
+-
+ </processor>
+ 
+ <processor name="MyEUTelUtilityPrintEventNumber" type="EUTelUtilityPrintEventNumber">
+diff --git a/processors/include/EUTelProcessorClusterAnalysis.h b/processors/include/EUTelProcessorClusterAnalysis.h
+index 2712b0f..3d3daac 100644
+--- a/processors/include/EUTelProcessorClusterAnalysis.h
++++ b/processors/include/EUTelProcessorClusterAnalysis.h
+@@ -58,11 +58,6 @@ protected:
+   int _chipVersion;
+   int _numberofGeneratedInterestingCluster;
+   int _numberofMissingInterestingCluster;
+-  int _number_emptyMiddle;
+-  int cuttingSize;
+-  int numberRandomEvent;
+-  int number_fireing_event;
+-  std::vector<std::vector<int>>before_event_memory;
+   double _energy;
+   EVENT::StringVec _chipID;
+   EVENT::StringVec _irradiation;
+@@ -73,12 +68,6 @@ protected:
+   bool _noiseMaskAvailable;
+   bool _deadColumnAvailable;
+   bool samecluster;
+-  bool I_Need_Distance_Square_Analysis;
+-  bool I_Need_Empty_Middle_Analysis;
+-  bool I_Need_Plote_Size_Cut_Hitmap;
+-  bool I_Need_Plot_Example_Events;
+-  bool I_Need_Fireing_Probability_Analysis;
+-  bool I_Need_How_Many_Pixels_Fire_In_An_Event;
+   std::string _hotPixelCollectionName;
+   std::string _deadColumnCollectionName;
+   std::string _noiseMaskFileName;
+@@ -101,25 +90,16 @@ private:
+   std::map<int,TH1I*> clusterSizeHisto;
+   std::map<int,TH2I*> GeneratedInterestingCluster;
+   std::map<int,TH2I*> MissingInterestingCluster;
+-  std::map<int,TH2I*> emptyMiddleClusters;
+-  std::map<int,TH2I*> RandomEvent;
+-  std::map<int,TH2I*> Double_Fireing_Events_Hitmap;
+   TH1I* timeStampHisto;
+   TH1I* GeneratedClustersHisto;
+   TH1I* MissingClusterHisto;
+   TH1I* HowManyClusterGeneratedFromOneCluster;
+   TH1I* GeneratedClusterShapeHisto;
+   TH1I* MissingClusterShapeHisto;
+-  TH1I* emptyMiddleClustersHisto;
+-  TH1I* NumberOfHits;
+-  TH1I* TypeOfTheEvent;
+   TH2I* hotpixelHisto;
+   TH2I* deadColumnHisto;
+   TH2I* circularClusterHistos;
+   TH2I* largeClusterHistos;
+-  TH2I* smallerClustersHitmap;
+-  TH2I* biggerClustersHitmap;
+-  TH2I* Fireing_Probability;
+   TH3I* clusterShapeMap;
+   std::map<int,TH1I*> clusterShapeHistoSector;
+   std::map<int,TH1I*> clusterShapeHistoGroupedSector;
+diff --git a/processors/src/EUTelProcessorAnalysisPALPIDEfs.cc b/processors/src/EUTelProcessorAnalysisPALPIDEfs.cc
+index afef2e0..40da419 100644
+--- a/processors/src/EUTelProcessorAnalysisPALPIDEfs.cc
++++ b/processors/src/EUTelProcessorAnalysisPALPIDEfs.cc
+@@ -1814,182 +1814,36 @@ int EUTelProcessorAnalysisPALPIDEfs::AddressToRow(int AAddress)
+ 
+ bool EUTelProcessorAnalysisPALPIDEfs::emptyMiddle(vector<vector<int> > pixVector)
+ {
+-	int type_of_emptyMiddle=3;
+-
+-	if(type_of_emptyMiddle==1)
+-	{
+-		bool holeX = false;
+-		bool holeY = false;
+-		for (size_t i=0; i<pixVector.size(); i++)
+-	  {
+-	    bool touchingX = false;
+-	    bool lastX = true;
+-	    for (size_t j=0; j<pixVector.size(); j++)
+-	    {
+-	      if (i==j) continue;
+-	      if (pixVector[i][1] != pixVector[j][1]) continue;
+-	      if (pixVector[i][0]+1 == pixVector[j][0]) { touchingX = true; break;}
+-	      if (pixVector[i][0] <  pixVector[j][0]) { lastX  = false;}
+-	    }
+-	    if (!touchingX && !lastX) { holeX = true; break;}
+-	  }
+-	  for (size_t i=0; i<pixVector.size(); i++)
+-	  {
+-	    bool touchingY = false;
+-	    bool lastY = true;
+-	    for (size_t j=0; j<pixVector.size(); j++)
+-	    {
+-	      if (i==j) continue;
+-	      if (pixVector[i][0] != pixVector[j][0]) continue;
+-	      if (pixVector[i][1]+1 == pixVector[j][1]) { touchingY = true; break;}
+-	      if (pixVector[i][1] <  pixVector[j][1]) { lastY  = false;}
+-	    }
+-	    if (!touchingY && !lastY) { holeY = true; break;}
+-	  }
+-	  if (holeX && holeY) return true;
+-	  else return false;
+-	}
+-
+-
+-	if(type_of_emptyMiddle==2)
+-	{
+-	  int xMax=0, yMax=0, xMin=10000, yMin=10000;
+-	  bool higherX=false, lowerX=false, higherY=false, lowerY=false;
+-	
+-	  for (size_t i=0; i<pixVector.size(); i++)
+-	  {
+-			if(pixVector[i][0]>xMax) xMax=pixVector[i][0];
+-			if(pixVector[i][0]<xMin) xMin=pixVector[i][0];
+-			if(pixVector[i][1]>yMax) yMax=pixVector[i][1];
+-			if(pixVector[i][1]<yMin) yMin=pixVector[i][1];
+-		}
+-	
+-	//cout<<"xMax: "<<xMax<<"xMin: "<<xMin<<"yMax: "<<yMax<<"yMin: "<<yMin<<endl;
+-		bool stop=false;
+-		for(int i=xMin; i<=xMax&&!stop; i++)
+-		{
+-			for(int j=yMin; j<=yMax&&!stop;j++)
+-			{
+-			higherX=false; lowerX=false; higherY=false; lowerY=false;
+-				for(int n=0; n<pixVector.size();n++)
+-				{
+-					if(pixVector[n][0]==i&&pixVector[n][1]==j) { higherX=false; lowerX=false; higherY=false; lowerY=false; break; }
+-					if(pixVector[n][0]==i&&pixVector[n][1]<j) lowerY=true;
+-					if(pixVector[n][0]==i&&pixVector[n][1]>j) higherY=true;
+-					if(pixVector[n][0]<i&&pixVector[n][1]==j) lowerX=true;
+-					if(pixVector[n][0]>i&&pixVector[n][1]==j) higherX=true;
+-				}
+-				if(higherX&&lowerX&&higherY&&lowerY) stop=true;
+-			}
+-		}
+-	if(higherX && lowerX && higherY && lowerY) return true;
+-	else return false;
+-	}
+-
+-
+-	if(type_of_emptyMiddle==3)
+-	{
+-
+-
+-           	std::vector<EUTelGenericSparsePixel> hitPixelVec;
+-
+-	        std::vector<EUTelGenericSparsePixel> newlyAdded;
+-
+-		//int firsthclustersize=hitPixelVec.size();
+-		int xMax=0, yMax=0, xMin=10000, yMin=10000;
+-		for (size_t i=0; i<pixVector.size(); i++)
+-		{
+-			if(pixVector[i][0]>xMax) xMax=pixVector[i][0];
+-			if(pixVector[i][0]<xMin) xMin=pixVector[i][0];
+-			if(pixVector[i][1]>yMax) yMax=pixVector[i][1];
+-			if(pixVector[i][1]<yMin) yMin=pixVector[i][1];
+-		}
+-		for(int n=xMin-1; n<=xMax+1; n++)
+-		{
+-			for(int m=yMin-1; m<=yMax+1; m++)
+-			{
+-				bool empty_pixel=true;
+-				for (size_t i=0; i<pixVector.size(); i++)
+-				{
+-					if(n==pixVector[i][0]&&m==pixVector[i][1]) { empty_pixel=false; break; }
+-				}
+-				if(empty_pixel)
+-				{
+-					EUTelGenericSparsePixel pixel;
+-					pixel.setXCoord(n);
+-					pixel.setYCoord(m);
+-					hitPixelVec.push_back(pixel);
+-				}
+-			}
+-		}
+-	
+-	        //We now cluster those hits together
+-		//while( !hitPixelVec.empty() )
+-            	{
+-
+-	
+-                	std::vector<EUTelGenericSparsePixel> cluCandidate;
+-
+-                	//First we need to take any pixel, so let's take the first one
+-                	//Add it to the cluster as well as the newly added pixels
+-                	newlyAdded.push_back( hitPixelVec.front() );
+-                	//sparseCluster->push_back( &(hitPixelVec.front()) );
+-                	cluCandidate.push_back( hitPixelVec.front() );
+-                	//And remove it from the original collection
+-                	hitPixelVec.erase( hitPixelVec.begin() );
+-
+-                	//Now process all newly added pixels, initially this is the just previously added one
+-                	//but in the process of neighbour finding we continue to add new pixels
+-                	while( !newlyAdded.empty() )
+-                	{
+-                    		bool newlyDone = true;
+-                    		int  x1, x2, y1, y2, dX, dY;
+-
+-                    		//check against all pixels in the hitPixelVec
+-                    		for( std::vector<EUTelGenericSparsePixel>::iterator hitVec = hitPixelVec.begin(); hitVec != hitPixelVec.end(); ++hitVec )
+-                    		{
+-      		                  	//get the relevant infos from the newly added pixel
+-                	        	x1 = newlyAdded.front().getXCoord();
+-                	        	y1 = newlyAdded.front().getYCoord();
+-	
+-                	        	//and the pixel we test against
+-                	        	x2 = hitVec->getXCoord();
+-                	        	y2 = hitVec->getYCoord();
+-	
+-                	        	dX = x1 - x2;
+-                	        	dY = y1 - y2;
+-                	        	int distance = dX*dX+dY*dY;
+-                	        	//if they pass the spatial and temporal cuts, we add them
+-					
+-					int _sparseMinDistanceSquaredComparison=1;
+-                	        	if( distance <= _sparseMinDistanceSquaredComparison )
+-                	        	{
+-                		            	//add them to the cluster as well as to the newly added ones
+-                		           	newlyAdded.push_back( *hitVec );
+-                		            	cluCandidate.push_back( *hitVec );
+-                		          	//	sparseCluster->push_back( &(*hitVec) );
+-                		            	hitPixelVec.erase( hitVec );
+-                		            	//for the pixel we test there might be other neighbours, we still have to check
+-                		            	newlyDone = false;
+-                		            	break;
+-                		        }
+-                		}
+-
+-       				//if no neighbours are found, we can delete the pixel from the newly added
+-				//we tested against _ALL_ non cluster pixels, there are no other pixels
+- 				//which could be neighbours
+-                		if(newlyDone) 
+-				{
+-					newlyAdded.erase( newlyAdded.begin() );
+-				}
+-             		}
+-		}
+-		if( !hitPixelVec.empty() ) return true;
+-		else return false;
+-
+-
+-
+-	}
++  bool holeX = false;
++  bool holeY = false;
++  for (size_t i=0; i<pixVector.size(); i++)
++  {
++    bool touchingX = false;
++    bool lastX = true;
++    for (size_t j=0; j<pixVector.size(); j++)
++    {
++      if (i==j) continue;
++      if (pixVector[i][1] != pixVector[j][1]) continue;
++      if (pixVector[i][0]+1 == pixVector[j][0]) {/*cerr << "Touching in x" << endl;*/ touchingX = true; break;}
++      if (pixVector[i][0] <  pixVector[j][0]) {/*cerr << "Smaller in x"  << endl;*/ lastX  = false;}
++    }
++    if (!touchingX && !lastX) {/*cerr << "Hole in X" << endl;*/ holeX = true; break;}
++  }
++  for (size_t i=0; i<pixVector.size(); i++)
++  {
++    bool touchingY = false;
++    bool lastY = true;
++    for (size_t j=0; j<pixVector.size(); j++)
++    {
++      if (i==j) continue;
++      if (pixVector[i][0] != pixVector[j][0]) continue;
++      if (pixVector[i][1]+1 == pixVector[j][1]) {/*cerr << "Touching in y" << endl;*/ touchingY = true; break;}
++      if (pixVector[i][1] <  pixVector[j][1]) {/*cerr << "Smaller in y"  << endl;*/ lastY  = false;}
++    }
++    if (!touchingY && !lastY) {/*cerr << "Hole in Y" << endl;*/ holeY = true; break;}
++  }
++  if (holeX && holeY) return true;
++  else return false;
+ }
+ 
+ bool EUTelProcessorAnalysisPALPIDEfs::RemoveAlign(LCCollectionVec * preAlignmentCollectionVec, LCCollectionVec * alignmentCollectionVec, LCCollectionVec * alignmentPAlpideCollectionVec, double* fitpos, double& xposfit, double& yposfit)
+diff --git a/processors/src/EUTelProcessorClusterAnalysis.cc b/processors/src/EUTelProcessorClusterAnalysis.cc
+index e5982f4..f84ec09 100644
+--- a/processors/src/EUTelProcessorClusterAnalysis.cc
++++ b/processors/src/EUTelProcessorClusterAnalysis.cc
+@@ -64,17 +64,7 @@ EUTelProcessorClusterAnalysis::EUTelProcessorClusterAnalysis()
+   _sparseMinDistanceSquaredComparison(1),
+   howmanypdf(0),
+   _numberofGeneratedInterestingCluster(0),
+-  _numberofMissingInterestingCluster(0),
+-  _number_emptyMiddle(0),
+-  cuttingSize(5),
+-  numberRandomEvent(0),
+-  I_Need_Distance_Square_Analysis(true),
+-  I_Need_Empty_Middle_Analysis(true),
+-  I_Need_Plote_Size_Cut_Hitmap(true),
+-  I_Need_Plot_Example_Events(true),
+-  I_Need_Fireing_Probability_Analysis(true),
+-  I_Need_How_Many_Pixels_Fire_In_An_Event(true),
+-  number_fireing_event(0)
++  _numberofMissingInterestingCluster(0)
+ 
+ 
+   {
+@@ -116,30 +106,15 @@ EUTelProcessorClusterAnalysis::EUTelProcessorClusterAnalysis()
+                              _rate, static_cast< string > ( "" ) );
+   registerOptionalParameter("ChipVersion", "Chip Version",
+                             _chipVersion, static_cast<int>(4) );
+-  registerOptionalParameter("I_Need_Distance_Square_Analysis", "I Need Distance Square Analysis",
+-                            I_Need_Distance_Square_Analysis, static_cast<bool>(true) );
+-  registerOptionalParameter("I_Need_Empty_Middle_Analysis", "I Need Empty Middle Analysis",
+-                            I_Need_Empty_Middle_Analysis, static_cast<bool>(true) );
+-  registerOptionalParameter("I_Need_Plote_Size_Cut_Hitmap", "I Need Plote Size Cut Hitmap",
+-                            I_Need_Plote_Size_Cut_Hitmap, static_cast<bool>(true) );
+-  registerOptionalParameter("I_Need_Plot_Example_Events", "I Need Plot Example Events",
+-                            I_Need_Plot_Example_Events, static_cast<bool>(true) );
+-  registerOptionalParameter("I_Need_Fireing_Probability_Analysis", "I Need Fireing Probability Analysis",
+-                            I_Need_Fireing_Probability_Analysis, static_cast<bool>(true) );
+-  registerOptionalParameter("I_Need_How_Many_Pixels_Fire_In_An_Event", "I Need How Many Pixels Fire In An Event",
+-                            I_Need_How_Many_Pixels_Fire_In_An_Event, static_cast<bool>(true) );
+-  registerOptionalParameter("_sparseMinDistanceSquaredComparison", "Sparse Min Distance Squared Comparison",
+-                            _sparseMinDistanceSquaredComparison, static_cast<int>(1) );
+     _isFirstEvent = true;
+-
+   }
+ 
+ void EUTelProcessorClusterAnalysis::init() {
+   _nLayer = geo::gGeometry().nPlanes();
+   const std::vector<int>& _planeID = geo::gGeometry().sensorIDsVec();
+-//cout<<"Here I am."<<endl;
++cout<<"Here I am."<<endl;
+ 
+-//cout<<_dutID<<endl;
++cout<<_dutID<<endl;
+   for(int iz=0; iz < _nLayer ; iz++)
+ 	  if(_planeID[iz]==_dutID)
+ 		  _layerIndex = iz;
+@@ -147,9 +122,9 @@ void EUTelProcessorClusterAnalysis::init() {
+   else if (_chipVersion==3) _nSectors = 8;
+   else if (_chipVersion==5) _nSectors = 4;
+   else                      _nSectors = 1;
+-/*cout<<"Here I am."<<endl;
++cout<<"Here I am."<<endl;
+ cout<<_chipVersion<<endl;
+-cout<<_nSectors<<endl;*/
++cout<<_nSectors<<endl;
+  
+   //beware, sometimes dutID is 3, sometimes it is 6
+   int iLayer = _dutID;
+@@ -174,19 +149,8 @@ cout<<_nSectors<<endl;*/
+   settingsFile.open (_outputSettingsFileName.c_str(), ios::out | ios::app );
+   if (newFile) settingsFile << "Run number;Energy;Chip ID;Chip Version;Irradiation level(0-nonIrradiated,1-2.5e12,2-1e13,3-700krad,4-combined:1e13+700krad);Rate;BB;Ithr;Idb;Vcasn;Vcasn2;Vclip;Vcasp;VresetP;VresetD;Threshold and their RMS for all eight sectors;Noise and their RMS for all eight sectors;Readout delay;Trigger delay;Strobe length;StrobeB length;Data (1) or noise (0);Number of events;Efficiency,Number of tracks,Number of tracks with associated hit for all sectors" << endl;
+ 
+-	//cerr<<"I_Need_Distance_Square_Analysis: "<<I_Need_Distance_Square_Analysis<<endl<<"I_Need_Empty_Middle_Analysis: "<<I_Need_Empty_Middle_Analysis<<endl<<"I_Need_Plote_Size_Cut_Hitmap: "<<I_Need_Plote_Size_Cut_Hitmap<<endl<<"I_Need_Plot_Example_Events: "<<I_Need_Plot_Example_Events<<endl<<"I_Need_Fireing_Probability_Analysis: "<<I_Need_Fireing_Probability_Analysis<<endl<<"I_Need_How_Many_Pixels_Fire_In_An_Event: "<<I_Need_How_Many_Pixels_Fire_In_An_Event<<endl;
+-
+-
+ }
+ 
+-
+-
+-
+-EUTelProcessorAnalysisPALPIDEfs* mypalpide= new EUTelProcessorAnalysisPALPIDEfs();
+-
+-
+-
+-
+ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
+ {
+ // INIT, DEAD COLOUMN AND HOT PIXEL CHECKS -----------------------------------------------------------------------------------------------------------------
+@@ -274,14 +238,8 @@ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
+ 
+   if (_clusterAvailable)
+   {
+-	int numberOfHitsInAnEvent=0;
+-	int numberOfSmallClusters=0;
+-	int numberOfBigClusters=0;
+-	std::vector<std::vector<int>>event_memory;
+-//cerr<<"IDETECTOR"<<endl;
+ 	for ( size_t idetector=0 ; idetector<zsInputDataCollectionVec->size(); idetector++)
+ 	{
+-//cerr<<"idetector: "<<idetector<<endl;
+ 		CellIDDecoder<TrackerDataImpl> cellDecoder( zsInputDataCollectionVec );
+ 		TrackerDataImpl * zsData = dynamic_cast< TrackerDataImpl * > ( zsInputDataCollectionVec->getElementAt(idetector) );
+ 		SparsePixelType   type   = static_cast<SparsePixelType> ( static_cast<int> (cellDecoder( zsData )["sparsePixelType"]) );
+@@ -383,7 +341,7 @@ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
+ 				}
+ 
+ 				//This part is to analysis the effect of the distance square between the pixels in one cluste
+-				if(I_Need_Distance_Square_Analysis)
++				if(true)
+ 				{		
+ 					samecluster=true;
+ 					int howmanyclustergeneratedfromonecluster(0);
+@@ -561,84 +519,8 @@ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
+ 
+ 				//The end of the part folr distance analysis
+ 
+-				//This par looking for holey clusters
+-
+-				//EUTelProcessorAnalysisPALPIDEfs* mypalpide= new EUTelProcessorAnalysisPALPIDEfs();
+-
+-				if(I_Need_Empty_Middle_Analysis)
+-				{
+-					//The next line check, if the cluster empty middled
+-					if(mypalpide->emptyMiddle(pixVector))
+-					{
+-						//It fill, the holey clusters histo
+-						emptyMiddleClustersHisto->Fill(clusterSize);
+-						//It select holey clusters, to see them.
+-						int xMin = *min_element(X.begin(), X.end());
+-						int xMax = *max_element(X.begin(), X.end());
+-						int yMin = *min_element(Y.begin(), Y.end());
+-						int yMax = *max_element(Y.begin(), Y.end());
+-						int Xshift= (xMin+xMax)/2 - 50/2;
+-						int Yshift= (yMin+yMax)/2 - 50/2;
+-						for(int i_emptyMiddle=0; i_emptyMiddle<pixVector.size()&&_number_emptyMiddle<100; i_emptyMiddle++)
+-						{
+-							emptyMiddleClusters[_number_emptyMiddle]->Fill(pixVector[i_emptyMiddle][0]-Xshift, pixVector[i_emptyMiddle][1]-Yshift);
+-						}
+-						_number_emptyMiddle++;
+-					}
+-				}
+-
+-				//The end of the holey clusters part
+-
+-				//This plot the clusters withe a cut in size
+ 
+-				if(I_Need_Plote_Size_Cut_Hitmap)
+-				{
+-					if(pixVector.size()<cuttingSize) numberOfSmallClusters++;
+-					if(pixVector.size()>=cuttingSize) numberOfBigClusters++;
+-					for(int i_cuttingSize=0; pixVector.size()<cuttingSize&&i_cuttingSize<pixVector.size(); i_cuttingSize++)
+-					{
+-						smallerClustersHitmap->Fill(pixVector[i_cuttingSize][0], pixVector[i_cuttingSize][1]);
+-					}
+-
+-					for(int i_cuttingSize=0; pixVector.size()>=cuttingSize&&i_cuttingSize<pixVector.size(); i_cuttingSize++)
+-					{
+-						biggerClustersHitmap->Fill(pixVector[i_cuttingSize][0], pixVector[i_cuttingSize][1]);
+-					}
+-
+-				}
+-
+-				//This part to plot events to see, the events.
+-
+-				if(I_Need_Plot_Example_Events)
+-				{
+-					bool INeedThisEvent=false;
+-					int nRandomEvent=0;
+-					if(numberRandomEvent<10) { INeedThisEvent=true; nRandomEvent=numberRandomEvent; cerr<<"I save the event: "<<numberRandomEvent<<" (the number of plot: "<<nRandomEvent<<")"<<endl; }
+-					if(numberRandomEvent>=1000000&&numberRandomEvent<1000010) { INeedThisEvent=true; nRandomEvent=numberRandomEvent-1000000+10; cerr<<"I save the event: "<<numberRandomEvent<<" the number of plot: "<<nRandomEvent<<")"<<endl; }
+-					if(numberRandomEvent>=2000000&&numberRandomEvent<2000010) { INeedThisEvent=true; nRandomEvent=numberRandomEvent-2000000+20; cerr<<"I save the event: "<<numberRandomEvent<<" (the number of plot: "<<nRandomEvent<<")"<<endl; }
+-					if(numberRandomEvent>=3000000&&numberRandomEvent<3000010) { INeedThisEvent=true; nRandomEvent=numberRandomEvent-3000000+30; cerr<<"I save the event: "<<numberRandomEvent<<" (the number of plot: "<<nRandomEvent<<")"<<endl; }
+-					if(numberRandomEvent>=4000000&&numberRandomEvent<4000010) { INeedThisEvent=true; nRandomEvent=numberRandomEvent-4000000+40; cerr<<"I save the event: "<<numberRandomEvent<<" (the number of plot: "<<nRandomEvent<<")"<<endl; }
+-
+-					for(int nnRandomEvent=0; nnRandomEvent<pixVector.size()&&INeedThisEvent; nnRandomEvent++)
+-					{
+-						RandomEvent[nRandomEvent]->Fill(pixVector[nnRandomEvent][0], pixVector[nnRandomEvent][1]);
+-					}
+-				}
+-
+-
+-
+-				//This part is to analysis if a pixel fires, will it fire higher probability the nex event?
+-				
+-				if(I_Need_Fireing_Probability_Analysis)
+-				{
+-					for(int i_event_memory=0; i_event_memory<pixVector.size(); i_event_memory++)
+-					{					
+-						event_memory.push_back(pixVector[i_event_memory]);
+-					}
+-				}
+ 
+-				//This line is to check how many pixel fired in an event.
+-				if(I_Need_How_Many_Pixels_Fire_In_An_Event) numberOfHitsInAnEvent+=pixVector.size();
+ 
+ 
+ 				streamlog_out ( DEBUG5 ) << "This is a DEBUG output to see whether the program gets here. The number X[0] is " << X[0] << " and _sectorWidth is " << _sectorWidth << endl; 
+@@ -682,66 +564,6 @@ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
+ 	nextCluster: ;
+ 	//End cluster for loop  
+ 	}
+-
+-	//How many pixel fired in one event
+-	if(I_Need_How_Many_Pixels_Fire_In_An_Event) NumberOfHits->Fill(numberOfHitsInAnEvent);
+-
+-	//What type of event
+-	if(I_Need_Plote_Size_Cut_Hitmap)
+-	{
+-		if(numberOfSmallClusters==0&&numberOfBigClusters==0) TypeOfTheEvent->Fill(0);
+-		if(numberOfSmallClusters>0&&numberOfBigClusters==0) TypeOfTheEvent->Fill(1);
+-		if(numberOfSmallClusters>0&&numberOfBigClusters==1) TypeOfTheEvent->Fill(2);
+-		if(numberOfSmallClusters>0&&numberOfBigClusters>1) TypeOfTheEvent->Fill(3);
+-		if(numberOfSmallClusters==0&&numberOfBigClusters>0) TypeOfTheEvent->Fill(4);
+-		//cerr<<"BigClusters: "<<numberOfBigClusters<<", SmallClusters: "<<numberOfSmallClusters<<endl;
+-	}
+-
+-	//It is for genereat some hitmap for an exsample event
+-	if(I_Need_Plot_Example_Events)
+-	{
+-		numberRandomEvent++;
+-	}
+-
+-	//This part is to analysis if a pixel fires, will it fire higher probability the nex event?
+-	if(I_Need_Fireing_Probability_Analysis)
+-	{
+-		//int xMax=0, yMax=0, xMin=10000, yMin=10000;
+-		bool interestin_event=false;
+-		for(int i_event_memory=0; i_event_memory<event_memory.size(); i_event_memory++)
+-		{
+-			bool there_is_a_double_fireing=false;
+-			for(int j_event_memory=0; j_event_memory<before_event_memory.size(); j_event_memory++)
+-			{
+-				if(event_memory[i_event_memory][0]==before_event_memory[j_event_memory][0]&&event_memory[i_event_memory][1]==before_event_memory[j_event_memory][1]) { there_is_a_double_fireing=true; interestin_event=true; break; }
+-			}
+-			if(there_is_a_double_fireing)
+-			{
+-				Fireing_Probability->Fill(event_memory[i_event_memory][0], event_memory[i_event_memory][1]);
+-				//if(event_memory[i_event_memory][0]>xMax) xMax=event_memory[i_event_memory][0];
+-				//if(event_memory[i_event_memory][0]<xMin) xMin=event_memory[i_event_memory][0];
+-				//if(event_memory[i_event_memory][1]>yMax) yMax=event_memory[i_event_memory][1];
+-				//if(event_memory[i_event_memory][1]>yMin) yMin=event_memory[i_event_memory][1];
+-			}
+-		}
+-		if(interestin_event)
+-		{
+-			for(int i_event_memory=0; i_event_memory<event_memory.size()&&number_fireing_event<100; i_event_memory++)
+-			{
+-				Double_Fireing_Events_Hitmap[number_fireing_event]->Fill(event_memory[i_event_memory][0], event_memory[i_event_memory][1]);
+-				Double_Fireing_Events_Hitmap[number_fireing_event]->Fill(event_memory[i_event_memory][0], event_memory[i_event_memory][1]);
+-			}
+-			for(int i_event_memory=0; i_event_memory<before_event_memory.size()&&number_fireing_event<100; i_event_memory++)
+-			{
+-				Double_Fireing_Events_Hitmap[number_fireing_event]->Fill(before_event_memory[i_event_memory][0], before_event_memory[i_event_memory][1]);
+-			}
+-			//Double_Fireing_Events_Hitmap[number_fireing_event]->Draw("colz");
+-			//Double_Fireing_Events_Hitmap[number_fireing_event]->GetYaxis()->SetRange(22,23);
+-			//Double_Fireing_Events_Hitmap[number_fireing_event]->SetAxisRange(yMin, yMax,"Y");
+-			number_fireing_event++;
+-		}
+-		before_event_memory=event_memory;
+-	}
+   }
+ 
+   //write the end event expression to the file, which is a linebreak
+@@ -777,57 +599,19 @@ void EUTelProcessorClusterAnalysis::bookHistos()
+       clusterShapeHistoSector[iSector] = new TH1I(Form("clusterShapeHisto_%d",iSector),Form("Cluster shape (all rotations separately) Sector %d;Cluster shape ID;a.u.",iSector),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
+       clusterShapeHistoGroupedSector[iSector] = new TH1I(Form("clusterShapeHistoGrouped_%d",iSector),Form("Cluster shape (all rotations treated together) Sector %d;Cluster shape ID;a.u.",iSector),symmetryGroups.size(),-0.5,symmetryGroups.size()-0.5);
+       GeneratedClustersHisto = new TH1I(Form("GeneratedClustersHisto"),Form("GeneratedClustersHisto;Cluster size (pixel);a.u."),200,0.5,200.5); 
+-	if(I_Need_Distance_Square_Analysis)
+-	{
+-      		MissingClusterHisto = new TH1I(Form("MissingClusterHisto"),Form("MissingClusterHisto;Cluster size (pixel);a.u."),200,0.5,200.5);
+-      		HowManyClusterGeneratedFromOneCluster = new TH1I(Form("HowManyClusterGeneratedFromOneCluster"),Form("HowManyClusterGeneratedFromOneCluster;Cluster size (pixel);a.u."),20,0.5,20.5);
+-      		GeneratedClusterShapeHisto = new TH1I(Form("GeneratedClusterShapeHisto"),Form("GeneratedClusterShapeHisto;Cluster size (pixel);a.u."),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
+-      		MissingClusterShapeHisto = new TH1I(Form("MissingClusterShapeHisto"),Form("MissingClusterShapeHisto;Cluster size (pixel);a.u."),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
+-	}
+-	if(I_Need_Empty_Middle_Analysis) emptyMiddleClustersHisto = new TH1I(Form("emptyMiddleClustersHisto"),Form("emptyMiddleClustersHisto;Cluster size (pixel);Number of Clusters"),200,0.5,200.5);
+-	if(I_Need_Plote_Size_Cut_Hitmap) smallerClustersHitmap = new TH2I(Form("smallerClustersHitmap"),Form("smallerClustersHitmap;X (pixel);Y (pixel)"),1024,0,1024,512,0,512);
+-	if(I_Need_Plote_Size_Cut_Hitmap) biggerClustersHitmap = new TH2I(Form("biggerClustersHitmap"),Form("biggerClustersHitmap;X (pixel);Y (pixel)"),1024,0,1024,512,0,512);
+-	if(I_Need_How_Many_Pixels_Fire_In_An_Event) NumberOfHits = new TH1I(Form("NumberOfHits"),Form("NumberOfHits;n_Hits;Number"),500,0.5,500.5);
+-	if(I_Need_Plote_Size_Cut_Hitmap) TypeOfTheEvent = new TH1I(Form("TypeOfTheEvent"),Form("TypeOfTheEvent;Type;Number"),5,-0.5,4.5);
+-	if(I_Need_Plote_Size_Cut_Hitmap) TypeOfTheEvent->SetMarkerStyle(21);
+-	if(I_Need_Fireing_Probability_Analysis) Fireing_Probability = new TH2I(Form("Fireing_Probability"),Form("Double fireing pixels;X (pixel);Y (pixel)"),1024,0,1024,512,0,512);
+-
+-
++      MissingClusterHisto = new TH1I(Form("MissingClusterHisto"),Form("MissingClusterHisto;Cluster size (pixel);a.u."),200,0.5,200.5);
++      HowManyClusterGeneratedFromOneCluster = new TH1I(Form("HowManyClusterGeneratedFromOneCluster"),Form("HowManyClusterGeneratedFromOneCluster;Cluster size (pixel);a.u."),20,0.5,20.5);
++      GeneratedClusterShapeHisto = new TH1I(Form("GeneratedClusterShapeHisto"),Form("GeneratedClusterShapeHisto;Cluster size (pixel);a.u."),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
++      MissingClusterShapeHisto = new TH1I(Form("MissingClusterShapeHisto"),Form("MissingClusterShapeHisto;Cluster size (pixel);a.u."),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
+ 	for(int nInterestingCluster=0; nInterestingCluster<100; nInterestingCluster++)
+ 	{
+-		if(I_Need_Distance_Square_Analysis)
+-		{
+-		      	AIDAProcessor::tree(this)->mkdir(Form("GeneratedInterestingCluster%d",iSector));
+-	      		AIDAProcessor::tree(this)->cd(Form("GeneratedInterestingCluster%d",iSector));
+-			GeneratedInterestingCluster[nInterestingCluster]  = new TH2I(Form("GeneratedInterestingCluster%		d",nInterestingCluster),Form(" Generated cluster, example %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),50,0,50,50,0,50);
+-	      		AIDAProcessor::tree(this)->mkdir(Form("MissingInterestingCluster%d",iSector));
+-	      		AIDAProcessor::tree(this)->cd(Form("MissingInterestingCluster%d",iSector));
+-			MissingInterestingCluster[nInterestingCluster]  = new TH2I(Form("MissingInterestingCluster%d",nInterestingCluster),Form	(" Missing cluster, example %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),50,0,50,50,0,50);
+-		}
+-		if(I_Need_Empty_Middle_Analysis)
+-		{
+-		      	AIDAProcessor::tree(this)->mkdir(Form("emptyMiddleClusters%d",iSector));
+-	      		AIDAProcessor::tree(this)->cd(Form("emptyMiddleClusters%d",iSector));
+-			emptyMiddleClusters[nInterestingCluster]  = new TH2I(Form("emptyMiddleClusters%d",nInterestingCluster),Form(" Holey cluster, example %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),50,0,50,50,0,50);
+-		}
+-	}
+-
+-	for(int nRandomEvent=0; nRandomEvent<50&&I_Need_Plot_Example_Events; nRandomEvent++)
+-	{
+-      		AIDAProcessor::tree(this)->mkdir(Form("RandomEvent%d",iSector));
+-	      	AIDAProcessor::tree(this)->cd(Form("RandomEvent%d",iSector));
+-		RandomEvent[nRandomEvent]  = new TH2I(Form("RandomEvent%d",nRandomEvent),Form(" An Event for Demonstration %d;Cluster width X (pixel);Cluster width Y (pixel)",nRandomEvent),1024,0,1024,512,0,512);
+-		//cerr<<"I SAVE an event"<<endl;
++      AIDAProcessor::tree(this)->mkdir(Form("GeneratedInterestingCluster%d",iSector));
++      AIDAProcessor::tree(this)->cd(Form("GeneratedInterestingCluster%d",iSector));
++		GeneratedInterestingCluster[nInterestingCluster]  = new TH2I(Form("GeneratedInterestingCluster%d",nInterestingCluster),Form(" Generated cluster, example %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),50,0,50,50,0,50);
++      AIDAProcessor::tree(this)->mkdir(Form("MissingInterestingCluster%d",iSector));
++      AIDAProcessor::tree(this)->cd(Form("MissingInterestingCluster%d",iSector));
++		MissingInterestingCluster[nInterestingCluster]  = new TH2I(Form("MissingInterestingCluster%d",nInterestingCluster),Form(" Missing cluster, example %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),50,0,50,50,0,50);
+ 	}
+-
+-	for(int nRandomEvent=0; nRandomEvent<100&&I_Need_Fireing_Probability_Analysis; nRandomEvent++)
+-	{
+-      		AIDAProcessor::tree(this)->mkdir(Form("Double_Fireing_Events_Hitmap%d",iSector));
+-	      	AIDAProcessor::tree(this)->cd(Form("Double_Fireing_Events_Hitmap%d",iSector));
+-		Double_Fireing_Events_Hitmap[nRandomEvent]  = new TH2I(Form("Double_Fireing_Events_Hitmap%d",nRandomEvent),Form(" Double Fireing Events Hitmap %d;Cluster width X (pixel);Cluster width Y (pixel)",nRandomEvent),1024,0,1024,512,0,512);
+-		//cerr<<"I SAVE an event"<<endl;
+-	}
+-
+     }
+   streamlog_out ( DEBUG5 )  << "end of Booking histograms " << endl;
+ }
diff --git a/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clusterAnalysis-tmp.xml b/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clusterAnalysis-tmp.xml
index fdd6caf..b09cb5c 100644
--- a/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clusterAnalysis-tmp.xml
+++ b/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clusterAnalysis-tmp.xml
@@ -108,6 +108,29 @@
   <!--Data taking rate-->
   <parameter name="Rate" type="string" value="@Rate@"/>
   <!--parameter name="Verbosity" type="string" value="DEBUG"/-->
+  <!--I_Need_Distance_Square_Analysis-->
+  <parameter name="I_Need_Distance_Square_Analysis" type="bool" value="true"/>
+  <!--I_Need_Empty_Middle_Analysis-->
+  <parameter name="I_Need_Empty_Middle_Analysis" type="bool" value="true"/>
+  <!--I_Need_Plote_Size_Cut_Hitmap-->
+  <parameter name="I_Need_Plote_Size_Cut_Hitmap" type="bool" value="true"/>
+  <!--I_Need_Plot_Example_Events-->
+  <parameter name="I_Need_Plot_Example_Events" type="bool" value="true"/>
+  <!--I_Need_Double_Fireing_Analysis-->
+  <parameter name="I_Need_Double_Fireing_Analysis" type="bool" value="true"/>
+  <!--I_Need_How_Many_Pixels_Fire_In_An_Event-->
+  <parameter name="I_Need_How_Many_Pixels_Fire_In_An_Event" type="bool" value="true"/>
+  <!--I_need_a_hitmap-->
+  <parameter name="I_need_a_hitmap" type="bool" value="true"/>
+  <!--_sparseMinDistanceSquaredComparison-->
+  <parameter name="_sparseMinDistanceSquaredComparison" type="int" value="1"/>
+  <!--_chipVersion-->
+  <parameter name="ChipVersion" type="int" value="@whichChip@"/>
+  <!--This cluster size is the border between the small and the big clusters-->
+  <parameter name="cuttingSize" type="int" value="5"/>
+
+
+
 </processor>
 
 <processor name="MyEUTelUtilityPrintEventNumber" type="EUTelUtilityPrintEventNumber">
diff --git a/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clustering-tmp.xml b/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clustering-tmp.xml
index 710b97e..7e5c173 100644
--- a/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clustering-tmp.xml
+++ b/jobsub/examples/pALPIDEfs/steering-templates_pALPIDEfs_7/clustering-tmp.xml
@@ -148,6 +148,7 @@ Available types of the data format:
   <parameter name="SparseClusterCut" type="float" value="0.0"/>
   <!--Minimum distance between sparsified pixel ( touching == sqrt(2)) -->
   <parameter name="SparseMinDistance" type="float" value="1"/>
+  <parameter name="SparseMinDistanceSquared" type="float" value="2"/>
   <!--Threshold in SNR for seed pixel contained in ZS data-->
   <parameter name="SparseSeedCut" type="float" value="0.0"/>
   <!--verbosity level of this processor ("DEBUG0-4,MESSAGE0-4,WARNING0-4,ERROR0-4,SILENT")-->
diff --git a/processors/include/EUTelProcessorClusterAnalysis.h b/processors/include/EUTelProcessorClusterAnalysis.h
index 5ad63a3..07abe5b 100644
--- a/processors/include/EUTelProcessorClusterAnalysis.h
+++ b/processors/include/EUTelProcessorClusterAnalysis.h
@@ -55,6 +55,13 @@ protected:
   int _nNoiseMaskClusters;
   int _nDeadColumnClusters;
   int _sectorWidth;
+  int _chipVersion;
+  int _numberofGeneratedInterestingCluster;
+  int _numberofMissingInterestingCluster;
+  int _number_emptyMiddle;
+  int cuttingSize;
+  int number_firing_event;
+  std::vector<std::vector<int>>before_event_memory;
   double _energy;
   EVENT::StringVec _chipID;
   EVENT::StringVec _irradiation;
@@ -64,6 +71,14 @@ protected:
   bool _hotpixelAvailable;
   bool _noiseMaskAvailable;
   bool _deadColumnAvailable;
+  bool samecluster;
+  bool I_Need_Distance_Square_Analysis;
+  bool I_Need_Empty_Middle_Analysis;
+  bool I_Need_Plote_Size_Cut_Hitmap;
+  bool I_Need_Plot_Example_Events;
+  bool I_Need_Double_Firing_Analysis;
+  bool I_Need_How_Many_Pixels_Fire_In_An_Event;
+  bool I_need_a_hitmap;
   std::string _hotPixelCollectionName;
   std::string _deadColumnCollectionName;
   std::string _noiseMaskFileName;
@@ -79,14 +94,35 @@ private:
   int _nLayer;
   int _xPixel;
   int _yPixel;
+  int howmanypdf;
+  int _sparseMinDistanceSquaredComparison;
+  int savedRandomEvents;
   std::map<int,TH1I*> clusterWidthXHisto;
   std::map<int,TH1I*> clusterWidthYHisto;
   std::map<int,TH1I*> clusterSizeHisto;
+  std::map<int,TH2I*> GeneratedInterestingCluster;
+  std::map<int,TH2I*> MissingInterestingCluster;
+  std::map<int,TH2I*> emptyMiddleClusters;
+  std::map<int,TH2I*> RandomEvent;
+  std::map<int,TH2I*> Double_Firing_Events_Hitmap;
   TH1I* timeStampHisto;
+  std::map<int,TH1I*> GeneratedClustersHisto;
+  std::map<int,TH1I*> MissingClusterHisto;
+  std::map<int,TH1I*> HowManyClusterGeneratedFromOneCluster;
+  std::map<int,TH1I*> GeneratedClusterShapeHisto;
+  std::map<int,TH1I*> MissingClusterShapeHisto;
+  std::map<int,TH1I*> emptyMiddleClustersHisto;
+  TH1I* NumberOfHits;
+  TH1I* TypeOfTheEvent;
+  TH1I* CLUSTER_SIZE;
   TH2I* hotpixelHisto;
   TH2I* deadColumnHisto;
   TH2I* circularClusterHistos;
   TH2I* largeClusterHistos;
+  TH2I* smallerClustersHitmap;
+  TH2I* biggerClustersHitmap;
+  TH2I* doubleFiringPixels;
+  TH2I* HIT_MAP;
   TH3I* clusterShapeMap;
   std::map<int,TH1I*> clusterShapeHistoSector;
   std::map<int,TH1I*> clusterShapeHistoGroupedSector;
diff --git a/processors/src/EUTelProcessorAnalysisPALPIDEfs.cc b/processors/src/EUTelProcessorAnalysisPALPIDEfs.cc
index 40da419..d64d43a 100644
--- a/processors/src/EUTelProcessorAnalysisPALPIDEfs.cc
+++ b/processors/src/EUTelProcessorAnalysisPALPIDEfs.cc
@@ -1814,36 +1814,104 @@ int EUTelProcessorAnalysisPALPIDEfs::AddressToRow(int AAddress)
 
 bool EUTelProcessorAnalysisPALPIDEfs::emptyMiddle(vector<vector<int> > pixVector)
 {
-  bool holeX = false;
-  bool holeY = false;
-  for (size_t i=0; i<pixVector.size(); i++)
-  {
-    bool touchingX = false;
-    bool lastX = true;
-    for (size_t j=0; j<pixVector.size(); j++)
-    {
-      if (i==j) continue;
-      if (pixVector[i][1] != pixVector[j][1]) continue;
-      if (pixVector[i][0]+1 == pixVector[j][0]) {/*cerr << "Touching in x" << endl;*/ touchingX = true; break;}
-      if (pixVector[i][0] <  pixVector[j][0]) {/*cerr << "Smaller in x"  << endl;*/ lastX  = false;}
-    }
-    if (!touchingX && !lastX) {/*cerr << "Hole in X" << endl;*/ holeX = true; break;}
-  }
-  for (size_t i=0; i<pixVector.size(); i++)
-  {
-    bool touchingY = false;
-    bool lastY = true;
-    for (size_t j=0; j<pixVector.size(); j++)
-    {
-      if (i==j) continue;
-      if (pixVector[i][0] != pixVector[j][0]) continue;
-      if (pixVector[i][1]+1 == pixVector[j][1]) {/*cerr << "Touching in y" << endl;*/ touchingY = true; break;}
-      if (pixVector[i][1] <  pixVector[j][1]) {/*cerr << "Smaller in y"  << endl;*/ lastY  = false;}
-    }
-    if (!touchingY && !lastY) {/*cerr << "Hole in Y" << endl;*/ holeY = true; break;}
-  }
-  if (holeX && holeY) return true;
-  else return false;
+
+//In this step we use an invers clustering process. Firt, we create a rectangle, which is bigger than the cluster in every direction. Second, we fill the hitPixelVec with pixels, which did not fired. Third, we run the clustering process with this hitPixelVec. Forth, if when this process find one cluster, and hitPixelVec is not empty, we find an emty middle cluster, if the hitPixeVec is empty our cluster is not empty middle.
+
+        std::vector<EUTelGenericSparsePixel> hitPixelVec;
+
+	std::vector<EUTelGenericSparsePixel> newlyAdded;
+
+	int xMax=0, yMax=0, xMin=1000000, yMin=1000000;
+
+	for (size_t i=0; i<pixVector.size(); i++)
+	{
+		if(pixVector[i][0]>xMax) xMax=pixVector[i][0];
+		if(pixVector[i][0]<xMin) xMin=pixVector[i][0];
+		if(pixVector[i][1]>yMax) yMax=pixVector[i][1];
+		if(pixVector[i][1]<yMin) yMin=pixVector[i][1];
+	}
+	for(int n=xMin-1; n<=xMax+1; n++)
+	{
+		for(int m=yMin-1; m<=yMax+1; m++)
+		{
+			bool empty_pixel=true;
+			for (int i=0; i<pixVector.size(); i++)
+			{
+				if(n==pixVector[i][0]&&m==pixVector[i][1]) { empty_pixel=false; break; }
+			}
+			if(empty_pixel)
+			{
+				EUTelGenericSparsePixel pixel;
+				pixel.setXCoord(n);
+				pixel.setYCoord(m);
+				hitPixelVec.push_back(pixel);
+			}
+		}
+	}
+	
+        //We now cluster those hits together
+	//while( !hitPixelVec.empty() )
+ 	{
+
+	
+               	std::vector<EUTelGenericSparsePixel> cluCandidate;
+
+               	//First we need to take any pixel, so let's take the first one
+               	//Add it to the cluster as well as the newly added pixels
+               	newlyAdded.push_back( hitPixelVec.front() );
+               	//sparseCluster->push_back( &(hitPixelVec.front()) );
+               	cluCandidate.push_back( hitPixelVec.front() );
+               	//And remove it from the original collection
+               	hitPixelVec.erase( hitPixelVec.begin() );
+
+               	//Now process all newly added pixels, initially this is the just previously added one
+               	//but in the process of neighbour finding we continue to add new pixels
+               	while( !newlyAdded.empty() )
+               	{
+               		bool newlyDone = true;
+               		int  x1, x2, y1, y2, dX, dY;
+
+               		//check against all pixels in the hitPixelVec
+               		for( std::vector<EUTelGenericSparsePixel>::iterator hitVec = hitPixelVec.begin(); hitVec != hitPixelVec.end(); ++hitVec )
+               		{
+	                  	//get the relevant infos from the newly added pixel
+             	        	x1 = newlyAdded.front().getXCoord();
+              	        	y1 = newlyAdded.front().getYCoord();
+	
+               	        	//and the pixel we test against
+               	        	x2 = hitVec->getXCoord();
+               	        	y2 = hitVec->getYCoord();
+
+               	        	dX = x1 - x2;
+               	        	dY = y1 - y2;
+               	        	int distance = dX*dX+dY*dY;
+               	        	//if they pass the spatial and temporal cuts, we add them
+				
+				int _sparseMinDistanceSquaredComparison=1;
+               	        	if( distance <= _sparseMinDistanceSquaredComparison )
+               	        	{
+               		            	//add them to the cluster as well as to the newly added ones
+               		           	newlyAdded.push_back( *hitVec );
+               		            	cluCandidate.push_back( *hitVec );
+               		          	//	sparseCluster->push_back( &(*hitVec) );
+               		            	hitPixelVec.erase( hitVec );
+               		            	//for the pixel we test there might be other neighbours, we still have to check
+               		            	newlyDone = false;
+              		            	break;
+               		        }
+               		}
+			//if no neighbours are found, we can delete the pixel from the newly added
+			//we tested against _ALL_ non cluster pixels, there are no other pixels
+			//which could be neighbours
+               		if(newlyDone) 
+			{
+				newlyAdded.erase( newlyAdded.begin() );
+			}
+       		}
+	}
+	// If the hitPixelVec is not empty there is a empty middle cluster, because there must be an area inside the cluster, which is not connected to the area outside the cluster.
+	if( !hitPixelVec.empty() ) return true;
+	else return false;
 }
 
 bool EUTelProcessorAnalysisPALPIDEfs::RemoveAlign(LCCollectionVec * preAlignmentCollectionVec, LCCollectionVec * alignmentCollectionVec, LCCollectionVec * alignmentPAlpideCollectionVec, double* fitpos, double& xposfit, double& yposfit)
diff --git a/processors/src/EUTelProcessorClusterAnalysis.cc b/processors/src/EUTelProcessorClusterAnalysis.cc
index 0b37868..83c6c6d 100644
--- a/processors/src/EUTelProcessorClusterAnalysis.cc
+++ b/processors/src/EUTelProcessorClusterAnalysis.cc
@@ -3,6 +3,7 @@
 #include "EUTelAlignmentConstant.h"
 #include "EUTelGeometryTelescopeGeoDescription.h"
 #include "EUTelTrackerDataInterfacerImpl.h"
+#include "EUTelProcessorAnalysisPALPIDEfs.h"
 
 #include "marlin/Global.h"
 #include "marlin/AIDAProcessor.h"
@@ -58,7 +59,25 @@ EUTelProcessorClusterAnalysis::EUTelProcessorClusterAnalysis()
   _hotPixelCollectionName(""),
   _nLayer(0),
   _xPixel(),
-  _yPixel()
+  _yPixel(),
+  _chipVersion(4),
+  _sparseMinDistanceSquaredComparison(1),
+  howmanypdf(0),
+  _numberofGeneratedInterestingCluster(0),
+  _numberofMissingInterestingCluster(0),
+  _number_emptyMiddle(0),
+  cuttingSize(5),
+  I_Need_Distance_Square_Analysis(true),
+  I_Need_Empty_Middle_Analysis(true),
+  I_Need_Plote_Size_Cut_Hitmap(true),
+  I_Need_Plot_Example_Events(true),
+  I_Need_Double_Firing_Analysis(true),
+  I_Need_How_Many_Pixels_Fire_In_An_Event(true),
+  I_need_a_hitmap(true),
+  number_firing_event(0),
+  _layerIndex(-1),
+  savedRandomEvents(0)
+
 
   {
     _description="Analysing cluster properties such as cluster shape and average cluster size.";
@@ -97,15 +116,46 @@ EUTelProcessorClusterAnalysis::EUTelProcessorClusterAnalysis()
                              _irradiation, _stringVecExample );
     registerOptionalParameter("Rate","Data taking rate",
                              _rate, static_cast< string > ( "" ) );
+  registerOptionalParameter("ChipVersion", "Chip Version",
+                            _chipVersion, static_cast<int>(4) );
+  registerOptionalParameter("I_Need_Distance_Square_Analysis", "I Need Distance Square Analysis",
+                            I_Need_Distance_Square_Analysis, static_cast<bool>(true) );
+  registerOptionalParameter("I_Need_Empty_Middle_Analysis", "I Need Empty Middle Analysis",
+                            I_Need_Empty_Middle_Analysis, static_cast<bool>(true) );
+  registerOptionalParameter("I_Need_Plote_Size_Cut_Hitmap", "I Need Plote Size Cut Hitmap",
+                            I_Need_Plote_Size_Cut_Hitmap, static_cast<bool>(true) );
+  registerOptionalParameter("I_Need_Plot_Example_Events", "I Need Plot Example Events",
+                            I_Need_Plot_Example_Events, static_cast<bool>(true) );
+  registerOptionalParameter("I_Need_Double_Firing_Analysis", "I Need Double Firing Analysis",
+                            I_Need_Double_Firing_Analysis, static_cast<bool>(true) );
+  registerOptionalParameter("I_Need_How_Many_Pixels_Fire_In_An_Event", "I Need How Many Pixels Fire In An Event",
+                            I_Need_How_Many_Pixels_Fire_In_An_Event, static_cast<bool>(true) );
+  registerOptionalParameter("I_need_a_hitmap", "I Need A Hitmap",
+                            I_need_a_hitmap, static_cast<bool>(true) );
+  registerOptionalParameter("_sparseMinDistanceSquaredComparison", "Sparse Min Distance Squared Comparison",
+                            _sparseMinDistanceSquaredComparison, static_cast<int>(1) );
+  // This cluster size is the border between the small and the big clusters:
+  registerOptionalParameter("cuttingSize", "cuttingSize",
+                            cuttingSize, static_cast<int>(5) );
     _isFirstEvent = true;
+
   }
 
 void EUTelProcessorClusterAnalysis::init() {
   _nLayer = geo::gGeometry().nPlanes();
   const std::vector<int>& _planeID = geo::gGeometry().sensorIDsVec();
+
   for(int iz=0; iz < _nLayer ; iz++)
 	  if(_planeID[iz]==_dutID)
 		  _layerIndex = iz;
+  if(_layerIndex==-1) { cerr<<"Wrong DUT ID. Exiting."<<endl; return; }
+  
+  
+  if (_chipVersion < 3)     _nSectors = 4;
+  else if (_chipVersion==3) _nSectors = 8;
+  else if (_chipVersion==5) _nSectors = 4;
+  else                      _nSectors = 1;
+
  
   //beware, sometimes dutID is 3, sometimes it is 6
   int iLayer = _dutID;
@@ -130,14 +180,23 @@ void EUTelProcessorClusterAnalysis::init() {
   settingsFile.open (_outputSettingsFileName.c_str(), ios::out | ios::app );
   if (newFile) settingsFile << "Run number;Energy;Chip ID;Chip Version;Irradiation level(0-nonIrradiated,1-2.5e12,2-1e13,3-700krad,4-combined:1e13+700krad);Rate;BB;Ithr;Idb;Vcasn;Vcasn2;Vclip;Vcasp;VresetP;VresetD;Threshold and their RMS for all eight sectors;Noise and their RMS for all eight sectors;Readout delay;Trigger delay;Strobe length;StrobeB length;Data (1) or noise (0);Number of events;Efficiency,Number of tracks,Number of tracks with associated hit for all sectors" << endl;
 
+	//cerr<<"I_Need_Distance_Square_Analysis: "<<I_Need_Distance_Square_Analysis<<endl<<"I_Need_Empty_Middle_Analysis: "<<I_Need_Empty_Middle_Analysis<<endl<<"I_Need_Plote_Size_Cut_Hitmap: "<<I_Need_Plote_Size_Cut_Hitmap<<endl<<"I_Need_Plot_Example_Events: "<<I_Need_Plot_Example_Events<<endl<<"I_Need_Double_Firing_Analysis: "<<I_Need_Double_Firing_Analysis<<endl<<"I_Need_How_Many_Pixels_Fire_In_An_Event: "<<I_Need_How_Many_Pixels_Fire_In_An_Event<<endl;
+
+
 }
 
 void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
 {
 // INIT, DEAD COLOUMN AND HOT PIXEL CHECKS -----------------------------------------------------------------------------------------------------------------
 //
 //
-
+  if(_layerIndex==-1) { return; }
   int nClusterPerEvent = 0;
   if (_isFirstEvent)
   {
@@ -219,8 +278,14 @@ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
 
   if (_clusterAvailable)
   {
+	int numberOfHitsInAnEvent=0;
+	int numberOfSmallClusters=0;
+	int numberOfBigClusters=0;
+	std::vector<std::vector<int>>event_memory;
 	for ( size_t idetector=0 ; idetector<zsInputDataCollectionVec->size(); idetector++)
 	{
 		CellIDDecoder<TrackerDataImpl> cellDecoder( zsInputDataCollectionVec );
 		TrackerDataImpl * zsData = dynamic_cast< TrackerDataImpl * > ( zsInputDataCollectionVec->getElementAt(idetector) );
 		SparsePixelType   type   = static_cast<SparsePixelType> ( static_cast<int> (cellDecoder( zsData )["sparsePixelType"]) );
@@ -320,9 +385,278 @@ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
 					pix.push_back(Y[iPixel]);
 					pixVector.push_back(pix);
 				}
+
 				streamlog_out ( DEBUG5 ) << "This is a DEBUG output to see whether the program gets here. The number X[0] is " << X[0] << " and _sectorWidth is " << _sectorWidth << endl; 
 				//now, since all pixels are from the same sector, the sector number can be set.
 				int index = X[0]/_sectorWidth;
+
+				//This part is to analysis the effect of the distance square between the pixels in one cluste
+				if(I_Need_Distance_Square_Analysis)
+				{		
+					samecluster=true;
+					int howmanyclustergeneratedfromonecluster(0);
+					int AllGeneratedPixel(0);
+					int AllMissingPixel(0);
+
+					//Cluster mycluster;
+			
+           				std::vector<EUTelGenericSparsePixel> hitPixelVec = sparseData.getPixels();
+           				std::vector<EUTelGenericSparsePixel> hitPixelVec2 = sparseData.getPixels();
+
+				        std::vector<EUTelGenericSparsePixel> newlyAdded;
+
+
+
+					int firsthclustersize=hitPixelVec.size();
+			 	        //We now cluster those hits together
+            				while( !hitPixelVec.empty() )
+            				{
+
+	
+                				std::vector<EUTelGenericSparsePixel> cluCandidate;
+
+                				//First we need to take any pixel, so let's take the first one
+                				//Add it to the cluster as well as the newly added pixels
+                				newlyAdded.push_back( hitPixelVec.front() );
+                				//sparseCluster->push_back( &(hitPixelVec.front()) );
+                				cluCandidate.push_back( hitPixelVec.front() );
+                				//And remove it from the original collection
+                				hitPixelVec.erase( hitPixelVec.begin() );
+
+                				//Now process all newly added pixels, initially this is the just previously added one
+                				//but in the process of neighbour finding we continue to add new pixels
+                				while( !newlyAdded.empty() )
+                				{
+                    					bool newlyDone = true;
+                    					int  x1, x2, y1, y2, dX, dY;
+
+                    					//check against all pixels in the hitPixelVec
+                    					for( std::vector<EUTelGenericSparsePixel>::iterator hitVec = hitPixelVec.begin(); hitVec != hitPixelVec.end(); ++hitVec )
+                    					{
+      		                  				//get the relevant infos from the newly added pixel
+                	        				x1 = newlyAdded.front().getXCoord();
+                	        				y1 = newlyAdded.front().getYCoord();
+	
+                	        				//and the pixel we test against
+                	        				x2 = hitVec->getXCoord();
+                	        				y2 = hitVec->getYCoord();
+	
+                	        				dX = x1 - x2;
+                	        				dY = y1 - y2;
+                	        				int distance = dX*dX+dY*dY;
+                	        				//if they pass the spatial and temporal cuts, we add them
+	
+                	        				if( distance <= _sparseMinDistanceSquaredComparison )
+                	        				{
+                		            				//add them to the cluster as well as to the newly added ones
+                		           				newlyAdded.push_back( *hitVec );
+                		            				cluCandidate.push_back( *hitVec );
+                		          				//	sparseCluster->push_back( &(*hitVec) );
+                		            				hitPixelVec.erase( hitVec );
+                		            				//for the pixel we test there might be other neighbours, we still have to check
+                		            				newlyDone = false;
+                		            				break;
+                		        			}
+                		    			}
+
+       						        //if no neighbours are found, we can delete the pixel from the newly added
+					                //we tested against _ALL_ non cluster pixels, there are no other pixels
+ 					                //which could be neighbours
+                					if(newlyDone) 
+							{
+								newlyAdded.erase( newlyAdded.begin() );
+							}
+             					}
+
+						if(firsthclustersize!=cluCandidate.size())
+						{
+							samecluster=false;
+							howmanyclustergeneratedfromonecluster++;
+							AllGeneratedPixel+=cluCandidate.size();
+							GeneratedClustersHisto[index]->Fill(cluCandidate.size());
+							//cout<<"I filled GeneratedClustersHisto with: "<<cluCandidate.size()<<endl;
+						
+
+
+							int intrestingClusterSize=cluCandidate.size();
+							Cluster interestingCluster;
+							vector<int> X(intrestingClusterSize);
+							vector<int> Y(intrestingClusterSize);
+
+
+  							int iforX=0, Xmax=0,Ymax=0,Xmin=1000000,Ymin=1000000,Xshift=0,Yshift=0;
+                					while(!cluCandidate.empty())
+                					{
+								X[iforX]=cluCandidate.front().getXCoord();
+								Y[iforX]=cluCandidate.front().getYCoord();
+                    						cluCandidate.erase( cluCandidate.begin() );
+								if(X[iforX]<Xmin) Xmin=X[iforX];
+								if(Y[iforX]<Ymin) Ymin=Y[iforX];
+								if(X[iforX]>Xmax) Xmax=X[iforX];
+								if(Y[iforX]>Ymax) Ymax=Y[iforX];
+
+								iforX++;
+                					}
+
+							interestingCluster.set_values(intrestingClusterSize,X,Y);
+							GeneratedClusterShapeHisto[index]->Fill(interestingCluster.WhichClusterShape(interestingCluster, clusterVec));
+
+							Xshift=(Xmax+Xmin)/2-50/2;
+							Yshift=(Ymax+Ymin)/2-50/2;
+							for(int iforY=0; iforY<Y.size()&&_numberofGeneratedInterestingCluster<100; iforY++)
+							{
+								GeneratedInterestingCluster[_numberofGeneratedInterestingCluster]->Fill(X[iforY]-Xshift, Y[iforY]-Yshift);
+							//cout<<"_numberofGeneratedInterestingCluster: "<<_numberofGeneratedInterestingCluster<<" X: "<<X[iforY]-Xshift<<" Y: "<<Y[iforY]-Yshift<<endl;
+							}
+							_numberofGeneratedInterestingCluster++;
+
+							
+
+
+
+
+
+
+
+
+						}
+						
+
+					}
+			
+
+					if(!samecluster)
+					{
+						MissingClusterHisto[index]->Fill(firsthclustersize);
+						HowManyClusterGeneratedFromOneCluster[index]->Fill(howmanyclustergeneratedfromonecluster);
+						howmanyclustergeneratedfromonecluster=0;
+						AllMissingPixel=firsthclustersize;
+
+						//cout<<"I filled MissingClusterHisto with: "<<firsthclustersize<<endl;
+
+	  					int Xmax=0,Ymax=0,Xmin=1000000,Ymin=1000000,Xshift=0,Yshift=0;					
+						
+						for( std::vector<EUTelGenericSparsePixel>::iterator hitVecSparseData = hitPixelVec2.begin(); hitVecSparseData != hitPixelVec2.end()&&_numberofMissingInterestingCluster<100; ++hitVecSparseData )
+						{
+							if(hitVecSparseData->getXCoord()<Xmin) Xmin=hitVecSparseData->getXCoord();
+							if(hitVecSparseData->getYCoord()<Ymin) Ymin=hitVecSparseData->getYCoord();
+							if(hitVecSparseData->getXCoord()>Xmax) Xmax=hitVecSparseData->getXCoord();
+							if(hitVecSparseData->getYCoord()>Ymax) Ymax=hitVecSparseData->getYCoord();
+						}
+						Xshift=(Xmax+Xmin)/2-50/2;
+						Yshift=(Ymax+Ymin)/2-50/2;
+
+						for( std::vector<EUTelGenericSparsePixel>::iterator hitVecSparseData = hitPixelVec2.begin(); hitVecSparseData != hitPixelVec2.end()&&_numberofMissingInterestingCluster<100; ++hitVecSparseData )
+						{
+							MissingInterestingCluster[_numberofMissingInterestingCluster]->Fill(hitVecSparseData->getXCoord()-Xshift, hitVecSparseData->getYCoord()-Yshift);
+						}
+						_numberofMissingInterestingCluster++;
+
+					}
+
+					//cout<<"I have done the "<<idetector<<"th cluster"<<endl;
+
+					if(AllGeneratedPixel!=AllMissingPixel)
+					{
+						cerr<<"AllMissingPixel!=AllMissingPixel"<<endl;
+						cerr<<"AllMissingPixel: "<<AllMissingPixel<<endl;
+						cerr<<"AllGeneratedPixel: "<<AllGeneratedPixel<<endl;
+					}
+					AllMissingPixel=0;
+					AllGeneratedPixel=0;
+				}
+
+
+				//The end of the part folr distance analysis
+
+				//This par looking for holey clusters
+
+				if(I_Need_Empty_Middle_Analysis)
+				{
+
+					//This line is needed, because EUTelProcessorAnalysisPALPIDEfs will check if the cluster is empty middle, or not.
+					EUTelProcessorAnalysisPALPIDEfs* mypalpide= new EUTelProcessorAnalysisPALPIDEfs();
+
+					//The next line check, if the cluster empty middled
+					if(mypalpide->emptyMiddle(pixVector))
+					{
+						//It fill, the holey clusters histo
+						emptyMiddleClustersHisto[index]->Fill(pixVector.size());
+						//It select holey clusters, to see them.
+						int xMin = *min_element(X.begin(), X.end());
+						int xMax = *max_element(X.begin(), X.end());
+						int yMin = *min_element(Y.begin(), Y.end());
+						int yMax = *max_element(Y.begin(), Y.end());
+						int Xshift= (xMin+xMax)/2 - 50/2;
+						int Yshift= (yMin+yMax)/2 - 50/2;
+						for(int i_emptyMiddle=0; i_emptyMiddle<pixVector.size()&&_number_emptyMiddle<100; i_emptyMiddle++)
+						{
+							emptyMiddleClusters[_number_emptyMiddle]->Fill(pixVector[i_emptyMiddle][0]-Xshift, pixVector[i_emptyMiddle][1]-Yshift);
+						}
+						_number_emptyMiddle++;
+					}
+					delete mypalpide;
+				}
+
+				//The end of the holey clusters part
+
+				//This plot the clusters withe a cut in size
+
+				if(I_Need_Plote_Size_Cut_Hitmap)
+				{
+					if(pixVector.size()<cuttingSize) numberOfSmallClusters++;
+					if(pixVector.size()>=cuttingSize) numberOfBigClusters++;
+					for(int i_cuttingSize=0; pixVector.size()<cuttingSize&&i_cuttingSize<pixVector.size(); i_cuttingSize++)
+					{
+						smallerClustersHitmap->Fill(pixVector[i_cuttingSize][0], pixVector[i_cuttingSize][1]);
+					}
+
+					for(int i_cuttingSize=0; pixVector.size()>=cuttingSize&&i_cuttingSize<pixVector.size(); i_cuttingSize++)
+					{
+						biggerClustersHitmap->Fill(pixVector[i_cuttingSize][0], pixVector[i_cuttingSize][1]);
+					}
+
+				}
+
+				//This part is for the hitmap
+
+				if(I_need_a_hitmap)
+				{
+					for(int i_HITMAP=0; i_HITMAP<pixVector.size(); i_HITMAP++)
+					{
+						HIT_MAP->Fill(pixVector[i_HITMAP][0],pixVector[i_HITMAP][1]);
+					}
+				}
+
+				//This part to plots random events to see.
+
+				if(I_Need_Plot_Example_Events)
+				{
+					for(int i_random=0; i_random<pixVector.size()&&savedRandomEvents<100; i_random++)
+					{
+						RandomEvent[savedRandomEvents]->Fill(pixVector[i_random][0], pixVector[i_random][1]);
+					}
+				}
+
+
+
+				//This part is to analysis if a pixel fires, will it fire higher probability the nex event?
+				
+				if(I_Need_Double_Firing_Analysis)
+				{
+					for(int i_event_memory=0; i_event_memory<pixVector.size(); i_event_memory++)
+					{					
+						event_memory.push_back(pixVector[i_event_memory]);
+					}
+				}
+
+				//This line is to check how many pixel fired in an event.
+				if(I_Need_How_Many_Pixels_Fire_In_An_Event) numberOfHitsInAnEvent+=pixVector.size();
+
+
+
+
+
 				
 				//set the cluster
 				cluster.set_values(clusterSize,X,Y);
@@ -361,11 +695,70 @@ void EUTelProcessorClusterAnalysis::processEvent(LCEvent *evt)
 	nextCluster: ;
 	//End cluster for loop  
 	}
+
+	//How many pixel fired in one event
+	if(I_Need_How_Many_Pixels_Fire_In_An_Event) NumberOfHits->Fill(numberOfHitsInAnEvent);
+
+	//What type of event
+	if(I_Need_Plote_Size_Cut_Hitmap)
+	{
+		if(numberOfSmallClusters==0&&numberOfBigClusters==0) TypeOfTheEvent->Fill(0);
+		if(numberOfSmallClusters>0&&numberOfBigClusters==0) TypeOfTheEvent->Fill(1);
+		if(numberOfSmallClusters>0&&numberOfBigClusters==1) TypeOfTheEvent->Fill(2);
+		if(numberOfSmallClusters>0&&numberOfBigClusters>1) TypeOfTheEvent->Fill(3);
+		if(numberOfSmallClusters==0&&numberOfBigClusters>0) TypeOfTheEvent->Fill(4);
+		//cerr<<"BigClusters: "<<numberOfBigClusters<<", SmallClusters: "<<numberOfSmallClusters<<endl;
+	}
+
+	//It is for genereat some hitmap for an exsample event
+	if(I_Need_Plot_Example_Events)
+	{
+		savedRandomEvents++;
+	}
+
+	//This part is to analysis if a pixel fires, will it fire higher probability the nex event?
+	if(I_Need_Double_Firing_Analysis)
+	{
+		bool interestin_event=false;
+		for(int i_event_memory=0; i_event_memory<event_memory.size(); i_event_memory++)
+		{
+			bool there_is_a_double_firing=false;
+			for(int j_event_memory=0; j_event_memory<before_event_memory.size(); j_event_memory++)
+			{
+				if(event_memory[i_event_memory][0]==before_event_memory[j_event_memory][0]&&event_memory[i_event_memory][1]==before_event_memory[j_event_memory][1]) { there_is_a_double_firing=true; interestin_event=true; break; }
+			}
+			if(there_is_a_double_firing)
+			{
+				doubleFiringPixels->Fill(event_memory[i_event_memory][0], event_memory[i_event_memory][1]);
+			}
+		}
+		//In the next step, it is going to create some hitmap from the double firing event couples. If you see a pixel in the hitmap, which has:
+		// 1 entrie, it just fired in the firsth event.
+		// 2 entries, it just fired in the second event.
+		// 3 entries, it fired in both of the events.
+
+		if(interestin_event)
+		{
+
+			for(int i_event_memory=0; i_event_memory<event_memory.size()&&number_firing_event<100; i_event_memory++)
+			{
+				Double_Firing_Events_Hitmap[number_firing_event]->Fill(event_memory[i_event_memory][0], event_memory[i_event_memory][1]);
+				Double_Firing_Events_Hitmap[number_firing_event]->Fill(event_memory[i_event_memory][0], event_memory[i_event_memory][1]);
+			}
+			for(int i_event_memory=0; i_event_memory<before_event_memory.size()&&number_firing_event<100; i_event_memory++)
+			{
+				Double_Firing_Events_Hitmap[number_firing_event]->Fill(before_event_memory[i_event_memory][0], before_event_memory[i_event_memory][1]);
+			}
+			number_firing_event++;
+		}
+		before_event_memory=event_memory;
+	}
   }
 
   //write the end event expression to the file, which is a linebreak
   clusterAnalysisOutput << endl;
   //Increment number of events
   _nEvents++;
 }
 
@@ -390,17 +783,83 @@ void EUTelProcessorClusterAnalysis::bookHistos()
       AIDAProcessor::tree(this)->mkdir(Form("Sector_%d",iSector));
       AIDAProcessor::tree(this)->cd(Form("Sector_%d",iSector));
 
-      clusterWidthXHisto[iSector]  = new TH1I(Form("clusterWidthXHisto_%d",iSector),Form("Cluster width in X in sector %d;Cluster width X (pixel);a.u.",iSector),15,0.5,15.5);
-      clusterWidthYHisto[iSector]  = new TH1I(Form("clusterWidthYHisto_%d",iSector),Form("Cluster width in Y in sector %d;Cluster width Y (pixel);a.u.",iSector),15,0.5,15.5);
-      clusterSizeHisto[iSector]  = new TH1I(Form("clusterSizeHisto_%d",iSector),Form("Cluster size_%d;Cluster size (pixel);a.u.",iSector),20,0.5,20.5);
+      clusterWidthXHisto[iSector]  = new TH1I(Form("clusterWidthXHisto_%d",iSector),Form("Cluster width in X in sector %d;Cluster width X (pixel);a.u.",iSector),50,0.5,50.5);
+      clusterWidthYHisto[iSector]  = new TH1I(Form("clusterWidthYHisto_%d",iSector),Form("Cluster width in Y in sector %d;Cluster width Y (pixel);a.u.",iSector),50,0.5,50.5);
+      clusterSizeHisto[iSector]  = new TH1I(Form("clusterSizeHisto_%d",iSector),Form("Cluster size_%d;Cluster size (pixel);a.u.",iSector),200,0.5,200.5);
       clusterShapeHistoSector[iSector] = new TH1I(Form("clusterShapeHisto_%d",iSector),Form("Cluster shape (all rotations separately) Sector %d;Cluster shape ID;a.u.",iSector),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
-      clusterShapeHistoGroupedSector[iSector] = new TH1I(Form("clusterShapeHistoGrouped_%d",iSector),Form("Cluster shape (all rotations treated together) Sector %d;Cluster shape ID;a.u.",iSector),symmetryGroups.size(),-0.5,symmetryGroups.size()-0.5);
+      clusterShapeHistoGroupedSector[iSector] = new TH1I(Form("clusterShapeHistoGrouped_%d",iSector),Form("Cluster shape (all rotations treated together) Sector %d;Cluster shape ID;a.u.",iSector),symmetryGroups.size(),-0.5,symmetryGroups.size()-0.5); 
+	if(I_Need_Distance_Square_Analysis)
+	{
+		AIDAProcessor::tree(this)->mkdir(Form("Sector_%d/CompareHistogramsIfReduced_sparseMinDistanceSquared=%d",iSector,_sparseMinDistanceSquaredComparison));
+      		AIDAProcessor::tree(this)->cd(Form("Sector_%d/CompareHistogramsIfReduced_sparseMinDistanceSquared=%d",iSector,_sparseMinDistanceSquaredComparison));
+      		GeneratedClustersHisto[iSector] = new TH1I(Form("GeneratidClustersFromAnother_%d",iSector),Form("Generated clusters, if reduced _sparseMinDistanceSquared=%d, Sector %d;Cluster size (pixel);Number of clusters", _sparseMinDistanceSquaredComparison , iSector),200,0.5,200.5);
+      		MissingClusterHisto[iSector] = new TH1I(Form("DisintegratingClusters_%d",iSector),Form("Disintegrating clusters, if reduced _sparseMinDistanceSquared=%d, Sector %d;Cluster size (pixel);Number of clusters", _sparseMinDistanceSquaredComparison , iSector),200,0.5,200.5);
+      		HowManyClusterGeneratedFromOneCluster[iSector] = new TH1I(Form("HowManyClusterGeneratedFromOneCluster_%d",iSector),Form("How many cluster generated from one cluster if reduce _sparseMinDistanceSquared=%d, Sector %d;Number of generated clusters from one disintegrating cluster; number of missing clusters",_sparseMinDistanceSquaredComparison),20,0.5,20.5);
+      		GeneratedClusterShapeHisto[iSector] = new TH1I(Form("GeneratedClustersShape_%d",iSector),Form("These clusters generated, if reduced _sparseMinDistanceSquared=%d, Sector %d;Cluster size (pixel);Number of clusters", _sparseMinDistanceSquaredComparison , iSector),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
+		//The next line will use, if the Cluster Shape finder process can work with clusters, which have pixels touch with corner.
+      		//MissingClusterShapeHisto[iSector] = new TH1I(Form("MissingClusterShapeHisto_%d",iSector),Form("MissingClusterShapeHisto;Type of the cluster shape;Number of clusters"),clusterVec.size()+1,-0.5,clusterVec.size()+0.5);
+	}
+      	AIDAProcessor::tree(this)->cd(Form("Sector_%d",iSector));
+	if(I_Need_Empty_Middle_Analysis) emptyMiddleClustersHisto[iSector] = new TH1I(Form("emptyMiddleClustersHisto_%d",iSector),Form("Empty middle clusters histo in sector %d;Cluster size (pixel);Number of Clusters", iSector),200,0.5,200.5);
+
+    }
+    AIDAProcessor::tree(this)->cd("");
+    if(I_Need_Plote_Size_Cut_Hitmap) smallerClustersHitmap = new TH2I(Form("smallerClustersHitmap"),Form("This hitmap is filled withe clusters, which smaller than %d;X (pixel);Y (pixel)",cuttingSize),1024,0,1024,512,0,512);
+    if(I_Need_Plote_Size_Cut_Hitmap) biggerClustersHitmap = new TH2I(Form("biggerClustersHitmap"),Form("This hitmap is filled withe clusters, which equal or bigger than %d;X (pixel);Y (pixel)",cuttingSize),1024,0,1024,512,0,512);
+    if(I_Need_How_Many_Pixels_Fire_In_An_Event) NumberOfHits = new TH1I(Form("NumberOfHits"),Form("Number of hits in an event;n_Hits;Number of events"),500,0.5,500.5);
+    //0: There was no hit.
+    //1: There was just smaller clusters than cuttingSize.
+    //2: There was one cluster bigger or equal than cuttingSize and there was smaller clusters than cuttingSize.
+    //3: There was more than one cluster bigger or equal than cuttingSize and there was smaller clusters than cuttingSize.
+    //4: There was just bigger or equal clusters than cuttingSize.
+    if(I_Need_Plote_Size_Cut_Hitmap) TypeOfTheEvent = new TH1I(Form("TypeOfTheEvent"),Form("Type of the event;Type;Number of events"),5,-0.5,4.5);
+    //if(I_Need_Plote_Size_Cut_Hitmap) TypeOfTheEvent->SetMarkerStyle(21);
+    if(I_Need_Double_Firing_Analysis) doubleFiringPixels = new TH2I(Form("doubleFiringPixels"),Form("Double firing pixels;X (pixel);Y (pixel)"),1024,0,1024,512,0,512);
+    if(I_need_a_hitmap) HIT_MAP = new TH2I("hitMap",Form("HitMap;X (pixel); Y(pixel)"),1024,0,1024,512,0,512);
+
+    AIDAProcessor::tree(this)->mkdir(Form("First100Example"));
+    for(int nInterestingCluster=0; nInterestingCluster<100; nInterestingCluster++)
+    {
+    	if(I_Need_Distance_Square_Analysis)
+	{
+      		AIDAProcessor::tree(this)->mkdir(Form("First100Example/GeneratedClustersFromADisintegratingCluster"));
+      		AIDAProcessor::tree(this)->cd(Form("First100Example/GeneratedClustersFromADisintegratingCluster"));
+		GeneratedInterestingCluster[nInterestingCluster]  = new TH2I(Form("GeneratedClustersFromADisintegratingCluster_%d",nInterestingCluster),Form(" Generated cluster, example %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),50,0,50,50,0,50);
+      		AIDAProcessor::tree(this)->mkdir(Form("First100Example/DisintegratingCluster"));
+      		AIDAProcessor::tree(this)->cd(Form("First100Example/DisintegratingCluster"));
+		MissingInterestingCluster[nInterestingCluster]  = new TH2I(Form("MissingInterestingCluster_%d",nInterestingCluster),Form	(" Missing cluster, example %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),50,0,50,50,0,50);
+	}
+	if(I_Need_Empty_Middle_Analysis)
+	{
+	      	AIDAProcessor::tree(this)->mkdir(Form("First100Example/emptyMiddleClusters"));
+      		AIDAProcessor::tree(this)->cd(Form("First100Example/emptyMiddleClusters"));
+		emptyMiddleClusters[nInterestingCluster]  = new TH2I(Form("emptyMiddleClusters_%d",nInterestingCluster),Form(" Holey cluster, example %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),50,0,50,50,0,50);
+	} 
+        if(I_Need_Plot_Example_Events)
+        {
+            AIDAProcessor::tree(this)->mkdir(Form("First100Example/RandomEvent"));
+	    AIDAProcessor::tree(this)->cd(Form("First100Example/RandomEvent"));
+	    RandomEvent[nInterestingCluster]  = new TH2I(Form("RandomEvent_%d",nInterestingCluster),Form(" An Event for Demonstration %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),1024,0,1024,512,0,512);
+	    //cerr<<"I SAVE an event"<<endl;
+        }
+	//In the next step, it is going to create some hitmap from the double firing event couples. If you see a pixel in the hitmap, which has:
+	// 1 entrie, it just fired in the firsth event.
+	// 2 entries, it just fired in the second event.
+	// 3 entries, it fired in both of the events.
+        if(I_Need_Double_Firing_Analysis)
+        {
+            AIDAProcessor::tree(this)->mkdir(Form("First100Example/Double_Firing_Events"));
+      	    AIDAProcessor::tree(this)->cd(Form("First100Example/Double_Firing_Events"));
+	    Double_Firing_Events_Hitmap[nInterestingCluster]  = new TH2I(Form("Double_Firing_Events_Hitmap_%d",nInterestingCluster),Form(" Double Firing Events Hitmap %d;Cluster width X (pixel);Cluster width Y (pixel)",nInterestingCluster),1024,0,1024,512,0,512);
+	    //cerr<<"I SAVE an event"<<endl;
+        }
     }
   streamlog_out ( DEBUG5 )  << "end of Booking histograms " << endl;
 }
 
 void EUTelProcessorClusterAnalysis::end()
 {
+  if(_layerIndex==-1) { return; }
   for (int iSector=0; iSector<_nSectors; iSector++)
     {		
       for (unsigned int i=0; i<symmetryGroups.size(); i++)
@@ -425,6 +884,19 @@ void EUTelProcessorClusterAnalysis::end()
     }
   }
   //
+  if(true)
+  {
+    bool DistanceSquareWarning=true;
+    for(int i_sector=0; i_sector<_nSectors; i_sector++)
+    {
+      if(GeneratedClustersHisto[i_sector]->GetEntries()!=0)  DistanceSquareWarning=false;
+      if(MissingClusterHisto[i_sector]->GetEntries()!=0)  DistanceSquareWarning=false;
+    }
+    if(DistanceSquareWarning)
+    {
+      streamlog_out ( WARNING ) << "The histograms of the analysis disintegrating clusters are empty! It could mean you runned the clusterAnalysis with same, or higher _sparseMinDistanceSquaredComparison than the _sparseMinDistanceSquared was in clustering." << endl;
+    }
+  }
   streamlog_out ( MESSAGE4 ) << "The amount of processed events was " << _nEvents << endl;
   streamlog_out ( MESSAGE4 ) << "The amount of ignored clusters, because they were at an x-border of a sector were: " << _nTouchingBorderSectorClusters << endl;
   streamlog_out ( MESSAGE4 ) << "The amount of ignored clusters, because they were at a y-border of the chip were: " << _nTouchingBorderYClusters << endl;
