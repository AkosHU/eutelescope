/**

@mainpage EUTelescope 

This is a class documentation of the EUTelescope processors. For a detailed description, support and installation instructions please refer to the <a href="http:eutelescope.web.cern.ch">EUTelescope website</a>. Browse this documentation by clicking on the button above or putting a
keyword in the search field in top right corner of this page.
<br>
If you feel you don't know enough about the EUTelescope software then we encourage
you to have a look at the following pages:

@li @ref intro
@li <a href="eutelescope.web.cern.ch/content/installation">EUTelescope Installation</a>
@li Analysis basics (prepared for Analog sensors - MimoTel/Mimosa-18, many steps
are still valid for the digital sensors/Mimosa-26)
<ul>
<li> @ref preparation
<li> @ref analysis
</ul>
@li @ref pythonScripts 
@li @ref gridtools

The EUTelescope framework workflow for digital sensors (Mimosa 26) is summarised
<a href="http://atlas.desy.de/ibl/EUTelescope/SoftwareDevelopment/EUTelescope_Aug_2010_concept_scheme.pdf">here
<img border="none" src="http://atlas.desy.de/ibl/home/pdficon_small.gif"> </a>.

<br><br> If those information are not yet enough, contact us on the <a href="http://eutelescope.web.cern.ch/forum">EUTelescope Forum</a>.

*/

*****************************************************************************

/**

@page intro Introduction

This is the documentation page of the EUTelescope software
project. EUTelescope is a group of <a
href="http://ilcsoft.desy.de/marlin">Marlin</a> processors to be used
for analysis and reconstruction of data taken using the <a
href="http://www.eudet.org">EUDET</a> JRA1 pixel telescope. <br><br> The
main goal of the EUTelescope software is to go from raw data acquired
by a set of data aquisition boards to high level objects like tracks
crossing the telescope. Those tracks are used to characterized both
the telescope itself and any other position sensitive detector (DUT)
that can be inserted into the telescope setup.<br><br> The structure of
EUTelescope is very modular and the each processor is just taking care
of doing a particular task on the input collection and eventually add
other output collections that can be used by other following
processors. This approach has many advantages but some disadvantages
as well when compare against a monolithic approach where one processor
only is doing the full job from the beginning to the end (see below
@ref modular).<br><br> The main input of the full analysis chain is the
LCIO output file produced by the DAQ system containing the pixel raw
data. Along with that other data are also needed: as for example
calibration constants (pedestal and noise), eta distribution for each
sensor and alignment constants. These preparation steps (@ref
preparation) can be done using a complex conditional steering file, or
they can be processed beforehand using much simpler steering file.<br><br>
When the preparation steps are done, then the complete analysis chain
can be executed (@ref analysis).

@section modular Pros and cons of a modular approach

The basic idea of having a modular approach is to keep things as
simple as possible. Every single step of the full analysis chain that
goes from raw data to tracks can be processed step by step and the
output of each step is still self consistent and can be fed in to the
next step without any manipulation. Of course this is particularly
valuable during the debug phase when each processor has to be
controlled and checked against bugs. <br> <br> From an end user point of
view, having so many steps might result in a too complicated and
useless structure. In this case it would be better to have just one
big piece of code the user run it and the result file pops up at the
end.<br> <br> For the time being we would like to stick to the modular
approach that is also Marlin inherited and for the laziest end user,
we are providing example of complete steering files to have (almost)
everything done just launching a command.



*/

*****************************************************************************

/**

@page analysis Analysis chain

In this page we would like to summarize which processors have to be
used to go from raw data to tracks. 

\section histogram The histogram interface

The first processor one may want to add to the steering file is an
histogram interface. This processor is making the handling of
histograms very user friendly and available to all other
processor. This is not a compulsory element of the analysis chain, but
it is very encouraged. <br>Within the EUTelescope framework there are
actually two available histogramming interfaces:

@li the marlin::AIDAProcessor: provided by Marlin,

@li the eutelescope::ROOTProcessor: that is instead typical of
EUTelescope but still under development.

The user can decide which of one or even both should be used. Here
below is a typical xml configuration the AIDAProcessor

@code
 <processor name="AIDAHistogramInterface" type="AIDAProcessor">
  <!--
      Processor that handles AIDA files. Creates on directory per
      processor . Processors only need to create and fill the
      histograms, clouds and tuples. Needs to be the first
      ActiveProcessor
   -->
  <!-- compression of output file 0: false >0: true (default) -->
  <parameter name="Compress" type="int" value="1"/>
  <!-- filename without extension-->
  <parameter name="FileName" type="string" value="analysis-histo"/>
  <!-- type of output file xml (default) or root ( only OpenScientist)-->
  <parameter name="FileType" type="string" value="root"/>
</processor>
@endcode

Another tool offered by the EUTelescope framework is the
eutelescope::EUTelHistogramManager. This is an XML interpreter for the so
called "histoinfo.xml" file. This file contains the booking
information of the great part of the histograms booked and filled by
the EUTelescope processors. This is allowing to have well defined (and
not automatic) binning without the need of modify the hardcoded
binning information and re-compile.

This is an example of a histogram information file:

@code
<HistogramManager>
  <histos>

    <!-- EUTelCalibrateEvent --> 
    <histo name="RawDataDistHisto"  type="H1D" xBin="4096" xMin="-2048.5" xMax="2047.5"/>
    <histo name="DataDistHisto"     type="H1D" xBin="5000" xMin="-500"    xMax="500" />
    <histo name="CommonDistHisto"   type="H1D" xBin="100"  xMin="-10"     xMax="10" />
  </histos>
</HistogramManager>
@endcode

\section conditionload Loading the condition file

The second step in the analysis chain is to load the calibration file
also known as pedestal file and the eta function files. Those can prepared beforehand (@ref
pedestal and @ref eta) and the pedestal, noise and status collections should made
available to the following processors using a ConditionProcessor. In
fact those files can be real files or an entries of a
condition database. <br> Here below an example of ConditionProcessor
to be used to load collection from an LCIO file:

@code
 <processor name="LoadPedestalFile" type="ConditionsProcessor">
  <!--ConditionsProcessor provides access to conditions data  transparently from LCIO files or a databases, using LCCD-->
  <parameter name="SimpleFileHandler" type="StringVec"> pedestalDB pedestal_db.slcio pedestalDB </parameter>
  <parameter name="SimpleFileHandler" type="StringVec"> noiseDB pedestal_db.slcio noiseDB </parameter>
  <parameter name="SimpleFileHandler" type="StringVec"> statusDB pedestal_db.slcio statusDB </parameter>
  <parameter name="SimpleFileHandler" type="StringVec"> xEtaCondition etafile_db.slcio xEtaCondition </parameter>
  <parameter name="SimpleFileHandler" type="StringVec"> yEtaCondition etafile_db.slcio yEtaCondition </parameter>

 </processor>
@endcode

With this configuration the ContionsProcessors is loading from a file
named @c pedestal_db.slcio three different conditions and from a file
named @c etafile_db.slcio other two collections. A drawback of this
ConditionProcessor is that collections taken from LCIO file are made
read only and the user cannot modify them. This sounds reasonable for
calibration data until the user wants to keep the calibration
constants updated during the running analysis chain. If this is true,
i.e. if the user wants to run a pedestal update algorithm
(eutelescope::EUTelUpdatePedestalNoiseProcessor) then those
collections should be locally copied to writable ones. This second
task can be accomplished by the
eutelescope::EUTelCopyPedestalProcessor configured as follows:

@code
 <processor name="LocalCopyPedestal" type="EUTelCopyPedestalProcessor">
 <!--EUTelCopyPedestalProcessor copies the condition data into local writable collections-->
  <!--Noise input condition-->
  <parameter name="NoiseConditionName" type="string" lcioInType="TrackerData"> noiseDB </parameter>
  <!--Pedestal input condition-->
  <parameter name="PedestalConditionName" type="string" lcioInType="TrackerData"> pedestalDB </parameter>
  <!--Status input condition-->
  <parameter name="StatusConditionName" type="string" lcioInType="TrackerRawData"> statusDB </parameter>
  <!--Noise local collection-->
  <parameter name="NoiseCollectionName" type="string" lcioOutType="TrackerData"> noise </parameter>
  <!--Pedestal local collection-->
  <parameter name="PedestalCollectionName" type="string" lcioOutType="TrackerData"> pedestal </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioOutType="TrackerRawData"> status </parameter>
 </processor>
@endcode

One can do the exactly the same also for the eta conditions.

@todo Consider renaming EUTelCopyPedestalProcessor in EUTelCopyConditionProcessor

\section calibrate Apply the pedestal correction

Finally it is time to start doing something. The first thing to do is
to apply to the input data the calibration constants previously loaded
and now available in the event. This operation is taking the input
TrackerRawData and transforming them into TrackerData containing
calibrated data. This operation is done by the
eutelescope::EUTelCalibrateEventProcessor that is also responsible to
apply common mode suppression. The user can ask to this processor also
to fill the so-called detector low level debug histograms, a bunch of
big histograms containing information about the detector
functionality. <br> This is a typical configuration for this processor.

@code
 <processor name="ApplyPedestalCorrection" type="EUTelCalibrateEventProcessor">
 <!--EUTelCalibrateEventProcessor subtract the pedestal value from the input data-->
  <!--Noise from the condition file-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData"> noise </parameter>
  <!--Pedestal from the condition file-->
  <parameter name="PedestalCollectionName" type="string" lcioInType="TrackerData"> pedestal </parameter>
  <!--Input raw data collection-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData"> rawdata </parameter>
  <!--Pixel status from the condition file-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData"> status </parameter>
  <!--Name of the output calibrated data collection-->
  <parameter name="CalibratedDataCollectionName" type="string" lcioOutType="TrackerData"> data </parameter>
  <!--Flag to switch on (1) or off (0) the detector debug histogram filling-->
  <parameter name="DebugHistoFilling" type="int" value="0"/>
  <!--Threshold of pixel SNR for hit rejection-->
  <parameter name="HitRejectionCut" type="float" value="3.5"/>
  <!--Maximum allowed number of rejected pixel per event-->
  <parameter name="MaxNoOfRejectedPixels" type="int" value="3000"/>
  <!--Flag to switch on (1) or off (0) the common mode suppression algorithm-->
  <parameter name="PerformCommonMode" type="int" value="1"/>
</processor>
@endcode

\section clustering Search for clusters

With the calibrated data, it is possible to scan the matrix looking
for clusters, i.e. group of space correlated pixels all having signals
above a certain threshold. There are several different cluster
searching algorithm one can imagine, code and apply. Within the EUTelClusteringProcessor, the user can select
which searching criteria should be used, but irrespectively of that,
the output of this clustering processor should be a TrackerPulse
collection having for each pulse a TrackerData attached. The
TrackerPulse contains only general information about the cluster,
while the TrackerData contains the full set of information. For this
reason the TrackerData structure may depend of the clusterization
algorithm and for that purpose the user can apply on top of that the
eutelescope::EUTelVirtualCluster.
@see eutelescope::EUTelClusteringProcessor for more
details.

<br>
Here below an example of the configuration of eutelescope::EUTelClusteringProcessor

@code
 <processor name="ClusterFinder" type="EUTelClusteringProcessor">
 <!--EUTelClusteringProcessor subtract the pedestal value from the input data-->
  <!--Input calibrated data collection name-->
  <parameter name="DataCollectionName" type="string" lcioInType="TrackerData"> data </parameter>
  <!--Noise (input) collection name-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData"> noise </parameter>
  <!--Pixel status (input) collection name-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData"> status </parameter>
  <!--Cluster (output) collection name-->
  <parameter name="PulseCollectionName" type="string" lcioOutType="TrackerPulse"> cluster </parameter>
  <!--Threshold in SNR for cluster identification-->
  <parameter name="ClusterCut" type="float" value="3"/>
  <!--Maximum allowed cluster size along x (only odd numbers)-->
  <parameter name="ClusterSizeX" type="int" value="5"/>
  <!--Maximum allowed cluster size along y (only odd numbers)-->
  <parameter name="ClusterSizeY" type="int" value="5"/>
  <!--Select here which algorithm should be used for clustering-->
  <parameter name="ClusteringAlgo" type="string" value="FixedFrame"/>
  <!--Threshold in SNR for seed pixel identification-->
  <parameter name="SeedPixelCut" type="float" value="4.5"/>
 </processor>
@endcode

A further and more precise selection of clusters fulfilling a list of
selection criteria is available in the eutelescope::EUTelClusterFilter
processor.

After the clusters were found, the user may want to apply a cluster
separation processor in order to try to split clusters that were
merged. This task is accomplished by the
eutelescope::EUTelClusterSeparationProcessor that can be configured as below:

@code
 <processor name="ClusterSplitter" type="EUTelClusterSeparationProcessor">
 <!--EUTelClusterSeparationProcessor separates merging clusters-->
  <!--Cluster collection name -->
  <parameter name="ClusterCollectionName" type="string" lcioInType="TrackerPulse"> cluster </parameter>
  <!--Minimum distance allowed between separated clusters (0 == only touching clusters)-->
  <parameter name="MinimumDistance" type="float" value="0"/>
  <!--Select which algorithm to use for cluster separation-->
  <parameter name="SeparationAlgorithm" type="string" value="FlagOnly"/>
</processor>

@endcode

After the cluster searching, the user may want to update the
calibration constants using the current event. For that purpose, the
pedestal, noise and status collection should be made writable by the
eutelescope::EUTelCopyPedestalProcessor and then the
eutelescope::EUTelUpdatePedestalNoiseProcessor can be called with a
configuration similar to the follow one:

@code

 <processor name="PedestalUpdater" type="EUTelUpdatePedestalNoiseProcessor">
  <!--EUTelUpdatePedestalNoiseProcessor periodically updates the pedestaland noise values-->
  <!--Noise local collection-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData"> noise </parameter>
  <!--Pedestal local collection-->
  <parameter name="PedestalCollectionName" type="string" lcioInType="TrackerData"> pedestal </parameter>
  <!--Raw data collection name-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData"> rawdata </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData"> status </parameter>
  <!--The value of the fixed weight (only for fixed weight algorithm-->
  <parameter name="FixedWeightValue" type="int" value="100"/>
  <!--A pixel to be monitored (detectorID, xCoord, yCoord). Add as many line as this as you wish-->
  <parameter name="PixelMonitored" type="IntVec"> 0 10 15 </parameter>
  <!--The algorithm to be used for pedestal update-->
  <parameter name="UpdateAlgorithm" type="string" value="FixedWeight"/>
  <!--How often the algorithm should be applied-->
  <parameter name="UpdateFrequency" type="int" value="10"/>
 </processor>

@endcode

@section spacepoint From clusters to space points

The next step in the analysis procedure is to move from TrackerPulse
to TrackerHit or in other word we need to move from local cluster in
the detector frame of reference to space point in the telescope frame
of reference. This task is accomplished by the
eutelescope::EUTelHitMaker and this is the first processor that is
accessing to the geometry repository through GEAR. The xml file
describing the geometry has to be provided as a global information in
the steering file.

@code

   <global>
     ...
    <parameter name="GearXMLFile" value="gear-telescope.xml"/>
     ...
   </global>

@endcode
<br>
The user can also decide to apply or not the Eta function correction
just selecting a switch in steering file. For the time being, since
the geometry description of the telescope is still in a development
phase, some parameters are hard coded in the software. 
<br>
Again an configuration example for this processor.

@code
 <processor name="ApplyGeometry" type="EUTelHitMaker">
 <!--
     EUTelHitMaker is responsible to translate cluster centers from
     the local frame of reference to the external frame of reference
     using the GEAR geometry description
  -->
  <!--Cluster (pulse) collection name-->
  <parameter name="PulseCollectionName" type="string" lcioInType="TrackerPulse"> cluster </parameter>
  <!--Hit collection name-->
  <parameter name="HitCollectionName" type="string" lcioOutType="TrackerHit"> hit </parameter>
  <!--The name of the collections containing the eta function (x and y respectively)-->
  <parameter name="EtaCollectionName" type="StringVec"> xEtaCondition yEtaCondition </parameter>
  <!--Enable (==1) or disable eta correction-->
  <parameter name="EtaSwitch" type="int" value="1"/>
 </processor>
@endcode

@section alignment The alignment of the telescope and of the DUT
The alignment is a very crucial point for all tracking devices and we
are provinding the DUT user a procedure for the alignment of the
telescope planes and of the DUT planes itself. For this purpose the
developers of the EUTelescope framework included the powerful package
MillePede2 (http://www.desy.de/~blobel/mptalks.html) in the MarlinUtil
package and implemented the eutelescope::EUTelMille processor to execute the local
track fitting and also the global fitting and parameter minimization.

@todo The documentation of the eutelescope::EUTelMille class will be soon expanded,
including also a procedure the user can follow to perform the
telescope and the DUT alignment.

When the alignment procedur is over, the constants are then transfered
to a DB via a LCIO file (in the same way the pedestal / noise and
status collection). Using the eutelescope::EUTelApplyAlignmentProcessor it is possible to
correct the hit position for the following processors 

@section tracking The track fitting
We actually have three different track fitting processor included into
EUTelescope.

\li eutelescope::EUTelLineFit to recostruct one (and only one) track per event
using a straight line approximation.

\li eutelescope::EUTelMultiLineFit as the previous, but the number of tracks per
event can be greater than one.

\li eutelescope::EUTelTestFitter is the implementation of the analytical approach
keepin the multiple scattering contribution into account. This is the
reccomended fitter in case of low energy particle beam.

Once the fitting is done, the results are stored into a lcio::TrackImpl
object and nice plots can be displayed using the eutelescope::EUTelFitHistograms
and the eutelescope::EUTelDUTHistograms. We also offer the user the last chance of
integration converting the output track collection into a NTuple using
the eutelescope::EUTelFitTuple processor.

To have a better feeling of the track results, the user can also
profit from the eutelescope::EUTelEventViewer (requires a CED server running) to
display the telescope geometry, the position of the hits and the
obtained tracks. 


@section outputfile Saving the results

Saving the output file with all the needed collections is the task of
the eutelescope::EUTelOutputProcessor. The reason why we have a custom
output processor and we don't use the standard
marlin::LCIOOutputProcessor is because of the event structure in the
EUDAQ software. In fact the acquisition system is appending at the end
of a run an empty event called End Of Run Event that can be used by
serial input/output protocol (like SIO) to identify which is the last
event before the real end of file. The EUTelOutputProcessor just check
the presence of the EORE event at the end of the run and if it is
missing a new EORE is appended.  Many EUTelescope processors are using
the EORE to finish up the calculation or to throw a
RewindDataFilesException.<br>  If more than one input files are
processed at the same time, the user can decide to keep, or skip the
intermediate EORE in the output file. The behavior of the processor
can be changed using the SkipIntermediateEORE steering parameter.<br>
This output processor has to be used in every step because if we want
to be self consistent every step output file has to finish with an
EORE. <br> Another interesting use of this processor is the file
fix. If, in fact, for any reason should the DAQ fails to write the
EORE, this LCIO can be fed into this output processor that will append
at the end the EORE. The configuration of EUTelOutputProcessor is
almost identical to the one of the LCIOOutputProcessor but the
SkipIntermediateEORE.

@code
 <processor name="SaveOutputFile" type="EUTelOutputProcessor">
  <!--
     Writes the current event to the specified LCIO outputfile.  
     Eventually it adds a EORE at the of the file if it was missing. 
      Needs to be the last ActiveProcessor
  .-->
  <!--drops the named collections from the event-->
  <!--parameter name="DropCollectionNames" type="StringVec"> rawdata data pedestal noise status </parameter-->
  <!--drops all collections of the given type from the event-->
  <!--parameter name="DropCollectionTypes" type="StringVec"> TrackerRawData TrackerData </parameter-->
  <!-- name of output file -->
  <parameter name="LCIOOutputFile" type="string" value="tracking-output.slcio"/>
  <!--write mode for output file:  WRITE_APPEND or WRITE_NEW-->
  <parameter name="LCIOWriteMode" type="string" value="WRITE_NEW"/>
  <!--will split output file if size in kB exceeds given value - doesn't work with APPEND and NEW-->
  <!--parameter name="SplitFileSizekB" type="int" value="1992294"/-->
  <!--Set it to true to remove intermediate EORE in merged runs-->
  <parameter name="SkipIntermediateEORE" type="bool" value="true"/>

 </processor>


@endcode


*/

*****************************************************************************

/**

@page preparation Preparation steps

For the time being there are three preparation steps available within
the EUTelescope package, for the raw DAQ native format conversion
(@ref conversion), for the calculation of calibration constants (@ref
pedestal) and for eta functions (@ref eta).

@section conversion The raw data converter

This is the step zero of the analysis chain. The final DAQ software
will save an output file directly formatted in LCIO with the proper
event structure and the correct event model. For the time, especially 
for debug reason, the DAQ is saving data on file according to its own
native data format using its built-in Serializer. 
To translate from the native raw format to the LCIO raw format, a
 specific data reader has been developed (eutelescope::EUTelMimoTelReader). 
The basic idea behind this reader is instead of re-writing and
 re-inventing the deserializing procedure the DAQ software is using to
 write the output file, the EUTelescope is linking against the
 libeudaq shared library and using directly the native
 deserializer. This imply that the EUDAQ software should be installed
 in the system and available. To avoid building problem, this reader
 is actually built only if the USE_EUDAQ is defined. Here below an
 example of what should be added to the userlib.gmk and to the env.sh
 
 
@code
#--------------------------------------------------------------------------------
#     EUDAQ
#--------------------------------------------------------------------------------
USERLIBS += -L/data/TestBeam/Analysis/eudaq/trunk/main -leudaq
USERINCLUDES += -DUSE_EUDAQ -DEUDAQ_FUNC=__PRETTY_FUNCTION__
USERINCLUDES += -DEUDAQ_PLATFORM=PF_LINUX -I/data/TestBeam/Analysis/eudaq/trunk/main/include
@endcode

@code
#--------------------------------------------------------------------------------
#     EUDAQ
#--------------------------------------------------------------------------------
export EUDAQ=/h/TestBeam/Analysis/eudaq/trunk
export LD_LIBRARY_PATH="$EUDAQ/main:$LD_LIBRARY_PATH"
@endcode 

Another reader (eutelescope::EUTelStrasMimoTelReader) has been
 prepared in order to convert the output of the IPHC DAQ in LCIO
 format. In this case we didn't follow the approach used for the EUDAQ
 since we don't have any compatible libraries. So binary data are
 reintrepret according to
 eutelescope::EUTelStrasMimoTelReader::StrasEventHeader,
 eutelescope::EUTelStrasMimoTelReader::StrasEventTrailer and
 eutelescope::EUTelStrasMimoTelReader::StrasRunHeader. <br>
This reader should be improved and refurbished in order to make it
 more general.

@section pedestal The pedestal and noise calculator

The first step to be done is to calibrate the output of each pixel
detector in order to remove the constant and useless signal. Together
with this pedestal value also the noise figure is estimated as the
width of the pedestal distribution.

The output of this step is a condition file having two TrackerData and
one TrackerRawData for each detector module:

@li Pedestal collection (TrackerData): one per detector with the mean
output value of each pixel

@li Noise collection (TrackerData): one per detector with the noise
value for each pixel

@li Status collection (TrackerRawData): one per detector with the
status of each pixel. This can be used to hide some very bad pixels
from the rest of the analysis.

Those collections are meant to be condition data and for the time
being are saved to LCIO files but they can be moved to a
database. <br> There are two ways to generate good pedestal and noise
constants:

@li Producing them from a specific run (@ref pedestalnoisecalculator)

@li Assuming a known initial value and then keep them update (@ref
autopedestal)

@subsection pedestalnoisecalculator Calculating pedestal and noise 

The standard approach for pedestal and noise calculation consists on
having a special run with no or very few particles arriving on the
telescope (a so called pedestal run, indeed) that should be processed
in order to retrieve the mean value of the output signal of each pixel
and the correponding noise figure. This task is accomplished by a
specific processor named
eutelescope::EUTelPedestalNoiseProcessor. More details about the
calculation algorithms already implemented are provided within the
class description.<br>
Here below is an example of a steering file to produce the pedestal,
noise and status collection using eutelescope::EUTelPedestalNoiseProcessor
@code
  <marlin>
   <global> 
    <parameter name="LCIOInputFiles"> pedestal-run.slcio  </parameter> 
    <parameter name="GearXMLFile" value="gear-telescope.xml"/>
    <parameter name="MaxRecordNumber" value="5001"/> 
    <parameter name="SkipNEvents" value="0 "/> 
    <parameter name="SupressCheck" value="false"/> 
    <parameter name="Verbosity" value="MESSAGE"/>
   </global>
 
   <execute>
    <processor name="AIDAHistogrammingInterface"/>
    <processor name="PedestalAndNoiseCalculator"/>
   </execute>

   <processor name="AIDAHistogrammingInterface" type="AIDAProcessor">
    <!--
      Processor that handles AIDA files. Creates on directory per
      processor. Processors only need to create and fill the
      histograms, clouds and tuples. Needs to be the first
      ActiveProcessor
    -->
    <!-- compression of output file 0: false >0: true (default) -->
    <parameter name="Compress" type="int" value="1"/>
    <!-- filename without extension-->
    <parameter name="FileName" type="string" value="pedestal-histo"/>
    <!-- type of output file xml (default) or root ( only OpenScientist)-->
    <parameter name="FileType" type="string" value="root"/>
   </processor>
  
   <processor name="PedestalAndNoiseCalculator" type="EUTelPedestalNoiseProcessor">
    <!--EUTelPedestalNoiseProcessor computes the pedestal and noise values of a pixel detector-->
    <!--Input raw data collection-->
    <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData"> rawdata </parameter>
    <!--Threshold for bad pixel identification-->
    <parameter name="BadPixelMaskCut" type="float" value="3.5"/>
    <!--Select the algorithm for bad pixel masking-->
    <parameter name="BadPixelMaskingAlgorithm" type="string" value="NoiseDistribution"/>
    <!--Select the algorithm for pede/noise calculation-->
    <parameter name="CalculationAlgorithm" type="string" value="MeanRMS"/>
    <!--First event for pedestal calculation-->
    <parameter name="FirstEvent" type="int" value="0"/>
    <!--Threshold for rejection of hit pixel (SNR units)-->
    <parameter name="HitRejectionCut" type="float" value="4"/>
    <!--Last event for pedestal calculation-->
    <parameter name="LastEvent" type="int" value="-1"/>
    <!--Maximum allowed number of rejected pixels per event-->
    <parameter name="MaxNoOfRejectedPixels" type="int" value="1000"/>
    <!--Number of common mode suppression iterations-->
    <parameter name="NoOfCMIteration" type="int" value="1"/>
    <!--Noise collection name-->
    <!--parameter name="NoiseCollectionName" type="string" value="noiseDB"/-->
    <!--The filename (w/o .slcio) to store the pedestal file-->
    <parameter name="OutputPedeFile" type="string" value="pedestal-db"/>
    <!--Pedestal collection name-->
    <!--parameter name="PedestalCollectionName" type="string" value="pedestalDB"/-->
    <!--Status collection name-->
    <!--parameter name="StatusCollectionName" type="string" value="statusDB"/-->
   </processor>
  </marlin>
@endcode

It should be noted that the AIDAProcessor can be removed, but then no
control histogram will be produced. Another remark concerns the
absence of a LCIOOutputProcessor; this is not needed since is the
eutelescope::EUTelPedestalNoiseProcessor taking care of saving the
final pedestal/noise/status collection on the disk when the
calculation is over.<br>
The eutelescope::EUTelPedestalNoiseProcessor can be runned also in the
complete analysis scheme using a more complicated conditional steering
file, but for simplicity this is not recommended.

@subsection autopedestal Assuming initial pedestal value

Another possible approach for the preparation of good pedestal and
noise collection is to assume a certain reasonable value for both the
pedestal and noise of every pixel in the matrix and then let the
system update (correct) this value to a more correct one. This
approach is particularly interesting when dealing with detector having
a pretty uniform pedestal distribution over the full sensitive
area. <br>
An advantage of this approach is that the user does not need to
execute a specific run to have the pedestal output, but she/he has
just to put the eutelescope::EUTelAutoPedestalNoiseProcessor at the
beginning of the analysis chain and the
eutelescope::EUTelUpdatePedestalNoiseProcessor soon after the
clusterization processor. Here below an example of a steering file
using the automatic pedestal calculation, for more info also refer to
the eutelescope::EUTelAutoPedestalNoiseProcessor and
eutelescope::EUTelUpdatePedestalNoiseProcessor class description.

@code
<marlin>
 <global>
  <parameter name="LCIOInputFiles"> simuldata-run.slcio </parameter>
  <parameter name="GearXMLFile" value="gear-telescope.xml"/>
  <parameter name="MaxRecordNumber" value="5001"/>
  <parameter name="SkipNEvents" value="0"/>
  <parameter name="SupressCheck" value="false"/>
  <parameter name="Verbosity" value="MESSAGE"/>
 </global>

 <execute>
  <processor name="AIDAHistogramInterface"/>
  <processor name="AutomaticPedestalCalculator"/>
  <processor name="ApplyCalibration"/>
  <processor name="ClusterFinder"/>
  <processor name="ClusterSplitter"/>
  <processor name="PedestalUpdater"/>
  <processor name="SaveOutputFile"/>
 </execute>

 <processor name="AIDAHistogramInterface" type="AIDAProcessor">
 <!--
     Processor that handles AIDA files. Creates on directory per
     processor. Processors only need to create and fill the
     histograms,  clouds and tuples. Needs to be the first
     ActiveProcessor
 -->
  <!-- compression of output file 0: false >0: true (default) -->
  <parameter name="Compress" type="int" value="1"/>
  <!-- filename without extension-->
  <parameter name="FileName" type="string" value="analysis-histo"/>
  <!-- type of output file xml (default) or root ( only OpenScientist)-->
  <parameter name="FileType" type="string" value="root"/>
 </processor>

 <processor name="AutomaticPedestalCalculator" type="EUTelAutoPedestalNoiseProcessor">
  <!--EUTelAutoPedestalNoiseProcessor produces initial pedestal / noise / status with user provided values-->
  <!--Noise local collection-->
  <parameter name="NoiseCollectionName" type="string" lcioOutType="TrackerData"> noise </parameter>
  <!--Pedestal local collection-->
  <parameter name="PedestalCollectionName" type="string" lcioOutType="TrackerData"> pedestal </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioOutType="TrackerRawData"> status </parameter>
  <!--The initial value of noise (one value for detector)-->
  <parameter name="InitNoiseValue" type="FloatVec"> 1 1 1 1 1 1 </parameter>
  <!--The initial value of pedestal (one value for detector)-->
  <parameter name="InitPedestalValue" type="FloatVec"> 0 0 0 0 0 0 </parameter>
 </processor>

 <processor name="ApplyCalibration" type="EUTelCalibrateEventProcessor">
  <!--EUTelCalibrateEventProcessor subtract the pedestal value from the input data-->
  <!--Noise from the condition file-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData"> noise </parameter>
  <!--Pedestal from the condition file-->
  <parameter name="PedestalCollectionName" type="string" lcioInType="TrackerData"> pedestal </parameter>
  <!--Input raw data collection-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData"> rawdata </parameter>
  <!--Pixel status from the condition file-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData"> status </parameter>
  <!--Name of the output calibrated data collection-->
  <parameter name="CalibratedDataCollectionName" type="string" lcioOutType="TrackerData"> data </parameter>
  <!--Flag to switch on (1) or off (0) the detector debug histogram filling-->
  <parameter name="DebugHistoFilling" type="int" value="0"/>
  <!--Threshold of pixel SNR for hit rejection-->
  <parameter name="HitRejectionCut" type="float" value="3.5"/>
  <!--Maximum allowed number of rejected pixel per event-->
  <parameter name="MaxNoOfRejectedPixels" type="int" value="3000"/>
  <!--Flag to switch on (1) or off (0) the common mode suppression algorithm-->
  <parameter name="PerformCommonMode" type="int" value="1"/>
 </processor>

 <processor name="ClusterFinder" type="EUTelClusteringProcessor">
  <!--EUTelClusteringProcessor subtract the pedestal value from the input data-->
  <!--Input calibrated data collection name-->
  <parameter name="DataCollectionName" type="string" lcioInType="TrackerData"> data </parameter>
  <!--Noise (input) collection name-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData"> noise </parameter>
  <!--Pixel status (input) collection name-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData"> status </parameter>
  <!--Cluster (output) collection name-->
  <parameter name="PulseCollectionName" type="string" lcioOutType="TrackerPulse"> cluster </parameter>
  <!--Threshold in SNR for cluster identification-->
  <parameter name="ClusterCut" type="float" value="3"/>
  <!--Maximum allowed cluster size along x (only odd numbers)-->
  <parameter name="ClusterSizeX" type="int" value="5"/>
  <!--Maximum allowed cluster size along y (only odd numbers)-->
  <parameter name="ClusterSizeY" type="int" value="5"/>
  <!--Select here which algorithm should be used for clustering-->
  <parameter name="ClusteringAlgo" type="string" value="FixedFrame"/>
  <!--Threshold in SNR for seed pixel identification-->
  <parameter name="SeedPixelCut" type="float" value="4.5"/>
 </processor>

 <processor name="ClusterSplitter" type="EUTelClusterSeparationProcessor">
 <!--EUTelClusterSeparationProcessor separates merging clusters-->
  <!--Cluster collection name -->
  <parameter name="ClusterCollectionName" type="string" lcioInType="TrackerPulse"> cluster </parameter>
  <!--Minimum distance allowed between separated clusters (0 == only touching clusters)-->
  <parameter name="MinimumDistance" type="float" value="0"/>
  <!--Select which algorithm to use for cluster separation-->
  <parameter name="SeparationAlgorithm" type="string" value="FlagOnly"/>
 </processor>

 <processor name="PedestalUpdater" type="EUTelUpdatePedestalNoiseProcessor">
 <!--EUTelUpdatePedestalNoiseProcessor periodically updates the pedestaland noise values-->
  <!--Noise local collection-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData"> noise </parameter>
  <!--Pedestal local collection-->
  <parameter name="PedestalCollectionName" type="string" lcioInType="TrackerData"> pedestal </parameter>
  <!--Raw data collection name-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData"> rawdata </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData"> status </parameter>
  <!--The value of the fixed weight (only for fixed weight algorithm-->
  <parameter name="FixedWeightValue" type="int" value="100"/>
  <!--A pixel to be monitored (detectorID, xCoord, yCoord). Add as many line as this as you wish-->
  <parameter name="PixelMonitored" type="IntVec"> 0 10 15 </parameter>
  <!--The algorithm to be used for pedestal update-->
  <parameter name="UpdateAlgorithm" type="string" value="FixedWeight"/>
  <!--How often the algorithm should be applied-->
  <parameter name="UpdateFrequency" type="int" value="10"/>
 </processor>

 <processor name="SaveOutputFile" type="EUTelOutputProcessor">
  <!--
     Writes the current event to the specified LCIO outputfile. 
     Eventually it adds a EORE at the of the file if it was missing.
     Needs to be the last ActiveProcessor.
  -->
  <!--drops the named collections from the event-->
  <parameter name="DropCollectionNames" type="StringVec"> rawdata data pedestal noise status </parameter>
  <!--drops all collections of the given type from the event-->
  <!--parameter name="DropCollectionTypes" type="StringVec"> TrackerRawData TrackerData </parameter-->
  <!-- name of output file -->
  <parameter name="LCIOOutputFile" type="string" value="autopede-output.slcio"/>
  <!--write mode for output file:  WRITE_APPEND or WRITE_NEW-->
  <parameter name="LCIOWriteMode" type="string" value="WRITE_NEW"/>
  <!--will split output file if size in kB exceeds given value - doesn't work with APPEND and NEW-->
  <!--parameter name="SplitFileSizekB" type="int" value="1992294"/-->
 </processor>

</marlin>
@endcode


@section eta Eta function calculation

The Eta function is used to calculate the center of a cluster. It is
used as a non linear weighting function in the charge center of mass
calculation. An a priori calculation of the Eta function starting from
the pixel detector design and consequently the field distribution
within the sensor is practically unfeasible. An experimental approach
based on probability distribution is, instead, easy to apply and
assure good results. This is based on the fact that the probability to
find the cluster center is flat over the pixel surface; in other
words, there are no physical reasons way a certain region of a pixel
should collect more cluster centers than another. If there is such a
region, this can only derive from an artifact due to pixel design and
the way the charge is collected within the sensitive volume. <br>
Correcting the charge center of mass algorithm, introducing non linear
weights, can solve this problem and flat the probability
distribution. This non linear weighting function is called <b>Eta
function</b>. To calculate it starting from the experimental data, one
need as an input a large enough collection of clusters for each
detector layers in order to have a statistically significant amount of
cluster centers and apply to that the
eutelescope::EUTelCalculateEtaProcessor. This processor is taking care
of calculating the eta function of each detector in the two orthogonal
directions. More on the Eta function can be found in the
eutelescope::EUTelCalculateEtaProcessor class description. <br>
The output file of the Eta calculation phase is a condition LCIO file
(as for pedestal also this file can be moved to a condition database
through the abstract interface provided by LCCD) containing two
collections of eutelescope::EUTelEtaFunctionImpl one for each of the
two directions. Each collection contains as many objects as the number
of detectors in telescope.<br>
Also for Eta calculation one can imagine to have a complicated
conditional steering file performing on one loop the eta calculation
and the apply the calculation results on the second loop, but to keep
the procedure the simplest possible, the user should run on some input
files the Eta calculator processor and then, afterward, apply the
results to the hits. Exploiting the modular approach, one can
calculate the Eta functions (using for example the steering file
provided below) and save as an output file the TrackerPulse found. The
next run can then start directly with the eutelescope::EUTelHitMaker
processor using as input the output of the previous step.

@code
<marlin>
 <global>
  <parameter name="LCIOInputFiles"> simuldata-run.slcio </parameter>
  <parameter name="GearXMLFile" value="gear-telescope.xml"/>
  <parameter name="MaxRecordNumber" value="5001"/>
  <parameter name="SkipNEvents" value="0"/>
  <parameter name="SupressCheck" value="false"/>
  <parameter name="Verbosity" value="MESSAGE"/>
 </global>

 <execute>
  <processor name="AIDAHistogramInterface"/>
  <processor name="LoadPedestalFile"/>
  <processor name="LocalCopyPedestal"/>
  <processor name="ApplyPedestalCorrection"/>
  <processor name="ClusterFinder"/>
  <processor name="ClusterSplitter"/>
  <processor name="EtaCalculator"/>
  <if condition="EtaCalculator.isEtaCalculationFinished">
   <processor name="SaveOutputFile"/>
  </if>
 </execute>

 <processor name="AIDAHistogramInterface" type="AIDAProcessor">
  <!--
     Processor that handles AIDA files. Creates on directory per
     processor. Processors only need to create and fill the
     histograms, clouds and tuples. Needs to be the first
     ActiveProcessor
  -->
  <!-- compression of output file 0: false >0: true (default) -->
  <parameter name="Compress" type="int" value="1"/>
  <!-- filename without extension-->
  <parameter name="FileName" type="string" value="analysis-histo"/>
  <!-- type of output file xml (default) or root ( only OpenScientist)-->
  <parameter name="FileType" type="string" value="root"/>
 </processor>

 <processor name="LoadPedestalFile" type="ConditionsProcessor">
 <!--ConditionsProcessor provides access to conditions data  transparently from LCIO files or a databases, using LCCD-->
  <parameter name="SimpleFileHandler" type="StringVec"> pedestalDB pedestal_db.slcio pedestalDB </parameter>
  <parameter name="SimpleFileHandler" type="StringVec"> noiseDB pedestal_db.slcio noiseDB </parameter>
  <parameter name="SimpleFileHandler" type="StringVec"> statusDB pedestal_db.slcio statusDB </parameter>
 </processor>
 
 <processor name="LocalCopyPedestal" type="EUTelCopyPedestalProcessor">
  <!--EUTelCopyPedestalProcessor copies the condition data into local writable collections-->
  <!--Noise input condition-->
  <parameter name="NoiseConditionName" type="string" lcioInType="TrackerData"> noiseDB </parameter>
  <!--Pedestal input condition-->
  <parameter name="PedestalConditionName" type="string" lcioInType="TrackerData"> pedestalDB </parameter>
  <!--Status input condition-->
  <parameter name="StatusConditionName" type="string" lcioInType="TrackerRawData"> statusDB </parameter>
  <!--Noise local collection-->
  <parameter name="NoiseCollectionName" type="string" lcioOutType="TrackerData"> noise </parameter>
  <!--Pedestal local collection-->
  <parameter name="PedestalCollectionName" type="string" lcioOutType="TrackerData"> pedestal </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioOutType="TrackerRawData"> status </parameter>
 </processor>

 <processor name="ApplyPedestalCorrection" type="EUTelCalibrateEventProcessor">
  <!--EUTelCalibrateEventProcessor subtract the pedestal value from the input data-->
  <!--Noise from the condition file-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData"> noise </parameter>
  <!--Pedestal from the condition file-->
  <parameter name="PedestalCollectionName" type="string" lcioInType="TrackerData"> pedestal </parameter>
  <!--Input raw data collection-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData"> rawdata </parameter>
  <!--Pixel status from the condition file-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData"> status </parameter>
  <!--Name of the output calibrated data collection-->
  <parameter name="CalibratedDataCollectionName" type="string" lcioOutType="TrackerData"> data </parameter>
  <!--Flag to switch on (1) or off (0) the detector debug histogram filling-->
  <parameter name="DebugHistoFilling" type="int" value="0"/>
  <!--Threshold of pixel SNR for hit rejection-->
  <parameter name="HitRejectionCut" type="float" value="3.5"/>
  <!--Maximum allowed number of rejected pixel per event-->
  <parameter name="MaxNoOfRejectedPixels" type="int" value="3000"/>
  <!--Flag to switch on (1) or off (0) the common mode suppression algorithm-->
  <parameter name="PerformCommonMode" type="int" value="1"/>
 </processor>

 <processor name="ClusterFinder" type="EUTelClusteringProcessor">
  <!--EUTelClusteringProcessor subtract the pedestal value from the input data-->
  <!--Input calibrated data collection name-->
  <parameter name="DataCollectionName" type="string" lcioInType="TrackerData"> data </parameter>
  <!--Noise (input) collection name-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData"> noise </parameter>
  <!--Pixel status (input) collection name-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData"> status </parameter>
  <!--Cluster (output) collection name-->
  <parameter name="PulseCollectionName" type="string" lcioOutType="TrackerPulse"> cluster </parameter>
  <!--Threshold in SNR for cluster identification-->
  <parameter name="ClusterCut" type="float" value="3"/>
  <!--Maximum allowed cluster size along x (only odd numbers)-->
  <parameter name="ClusterSizeX" type="int" value="5"/>
  <!--Maximum allowed cluster size along y (only odd numbers)-->
  <parameter name="ClusterSizeY" type="int" value="5"/>
  <!--Select here which algorithm should be used for clustering-->
  <parameter name="ClusteringAlgo" type="string" value="FixedFrame"/>
  <!--Threshold in SNR for seed pixel identification-->
  <parameter name="SeedPixelCut" type="float" value="4.5"/>
 </processor>

 <processor name="ClusterSplitter" type="EUTelClusterSeparationProcessor">
  <!--EUTelClusterSeparationProcessor separates merging clusters-->
  <!--Cluster collection name -->
  <parameter name="ClusterCollectionName" type="string" lcioInType="TrackerPulse"> cluster </parameter>
  <!--Minimum distance allowed between separated clusters (0 == only touching clusters)-->
  <parameter name="MinimumDistance" type="float" value="0"/>
  <!--Select which algorithm to use for cluster separation-->
  <parameter name="SeparationAlgorithm" type="string" value="FlagOnly"/>
 </processor>

 <processor name="EtaCalculator" type="EUTelCalculateEtaProcessor">
  <!--EUTelCalculateEtaProcessor calculates the eta function for a given set of clusters-->
  <!--Input cluster collection-->
  <parameter name="ClusterCollectionName" type="string" lcioInType="TrackerData"> cluster </parameter>
  <!--To use only kGoodQuality write 0 here-->
  <parameter name="ClusterQualitySelection" type="int" value="0"/>
  <!--Write FULL: full cluster, NxMPixel: for a NxM sub-cluster, NPixel: to use only N pixel-->
  <parameter name="ClusterTypeSelection" type="string" value="FULL"/>
  <!--Set the name of the Eta collection along x-->
  <parameter name="EtaXCollectionName" type="string" value="xEtaCondition"/>
  <!--Set the name of the Eta collection along y-->
  <parameter name="EtaYCollectionName" type="string" value="yEtaCondition"/>
  <!--Write here how many events you want to use for eta calculation (-1 for all)-->
  <parameter name="EventNumber" type="int" value="-1"/>
  <!--The number of pixel with the highest signal (only for NPixel)-->
  <parameter name="NPixelSize" type="int" value="5"/>
  <!--Write here in how many bins the seed pixel should be divided (x and y)-->
  <parameter name="NumberOfBins" type="IntVec"> 1000 1000 </parameter>
  <!--The size along x and y of the subcluster (only for NxMPixel)-->
  <parameter name="NxMPixelClusterSize" type="IntVec"> 3 3 </parameter>
  <!--This is the name of the output condition file-->
  <parameter name="OutputEtaFileName" type="string" value="etafile"/>
 </processor>

 <processor name="SaveOutputFile" type="EUTelOutputProcessor">
  <!--
      Writes the current event to the specified LCIO outputfile. 
      Eventually it adds a EORE at the of the file if it was missing.
       Needs to be the last ActiveProcessor.
  -->
  <!--drops the named collections from the event-->
  <parameter name="DropCollectionNames" type="StringVec"> rawdata data pedestal noise status </parameter>
  <!--drops all collections of the given type from the event-->
  <!--parameter name="DropCollectionTypes" type="StringVec"> TrackerRawData TrackerData </parameter-->
  <!-- name of output file -->
  <parameter name="LCIOOutputFile" type="string" value="analysis-output.slcio"/>
  <!--write mode for output file:  WRITE_APPEND or WRITE_NEW-->
  <parameter name="LCIOWriteMode" type="string" value="WRITE_NEW"/>
  <!--will split output file if size in kB exceeds given value - doesn't work with APPEND and NEW-->
  <!--parameter name="SplitFileSizekB" type="int" value="1992294"/--> 
 </processor>
</marlin>
@endcode

*/
*****************************************************************************

/**

@page preparationDigital  Digital - preparation steps 

The section is being filled.

*/

*****************************************************************************

/**

@page analysisDigital  Digital - analysis chain 

The section is being filled.

*/

*****************************************************************************

/**

@page pythonScripts How to run python scripts. 

The steering (.xml) files, needed to define your analysis job the sequence and
parameters of the Processors, can be created with a set of python scripts. 
The python scripts described below are prepared to generate the steering files
based on the (.xml) templates and configuration files. The analysis job is
executed via Marlin program called at the end of the script.
Their name, short description and command line syntax is given below.

<ul>
<li> All python scripts should be executed in the $EUTELESCOPE/pysub/ folder.
Further on consider this folder as current = (./).
<li> Configuration files and templates:
<ul>
<li> The first uttermost imporant file is a geometry file defined in a gear file:
<ul>
<li> ../steering-examples/gear_telescope_2009_dut_m26_v1.0.xml
</ul>
<li> Second most important file is a configuration file:
<ul>
<li> ./config/config.cfg
<li> or a working copy of this file: ./config/config-DUT_ID-gear_ID.cfg to be used
in example lines below
</ul>
<li> Analysis job templates are stored in:
<ul>
<li> ./template_m26_telescope/
</ul>
<li> Python scripts are in:
<ul>
<li> ./ (current folder = $EUTELESCOPE/pysub)
<li> ./pysub/ (one level down - library of the python routines to be called by
main scripts)
</ul>


</ul>
<li> Several data format conversion operations:
<ul>
<li> Converter - convert a run from RAW (.raw) into LCIO (.slcio) format.
@code
 ./submit-converter.py  --config=config/config-DUT_ID-gear_ID.cfg [--hot 1000] 1000 
 # --config= defines the config file to be taken (default = config.cfg)
 # 1000 - run number (assuming now a no-beam run)
 # [--hot 1000] - optional parameter, should be given only for runs when there
 # was no beam, this option turns on the HotPixel Processor in the hot pixel
 # counting mode, the output collection is dumped in the
 # run1000-hotpixel-db.slcio file stored by default in the db/ folder
@endcode 
@code
 ./submit-converter.py  --config=config/config-DUT_ID-gear_ID.cfg  1001 
 # --config= defines the config file to be taken (default = config.cfg)
 # 1001 - run number 
 # [--hot 1001] - for real in-beam runs no special parameters should given! 
@endcode 

<li> Clustering - depending on the  sensor active area geometry and readout type
several algorithms are available.
@code
 ./submit-clusearch.py  --config=config/config-DUT_ID-gear_ID.cfg --hot 1000 1001
 # --config= defines the config file to be taken (default = config.cfg)
 # 1001 - run number 
 # --hot 1000 - a must parameter hot pixel collection db file (loads a db/run1000-hotpixel-db.slcio).
 # comment 1: the hot pixel run is usually one run, the distribution of hot
 # pixels in Mimosa 26 sensors does not seem to be run dependent.
 # comment 2: by defaul in the Correlator Processor the sensor offset values are
 # calculated, the results are dumped into a db/run01001-offset-db.sclio file.
 # This is done for every run.
@endcode 
<li> Filtering - prune cluster selection. This step is not needed by default,
can go directly to HitMaker.
@code
 ./submit-filter.py  --config=config/config-DUT_ID-gear_ID.cfg 1001
 # 1001 - run number 
@endcode 

<li> Hitmaker - translate clusters into space points (we call them Hits)
@code
 ./submit-hitmaker.py  --config=config/config-DUT_ID-gear_ID.cfg -o 1001 [-n 1001] run001001-filter.slcio 
 # -o 1001 - specify the output filename ( 1001-hit.slcio) 
 # run001001-filter.lscio - intput filename  
 # [-n 1001] - optional parameter (although a very much recommended one!). Turns
 # on the implementation of the sensor offset values calculated at the clusearch
 # step.
@endcode 

</ul>
<li> Build tracks, first to get all sensors aligned relative to each
other, then get final tracks.
<ul>
<li> Alignment - correct sensors 3D position and orientation. It is very important to
align the sensor  X and Y global coordinates and possible rotation in X-Y plane.
@code
 ./submit-align.py  [-f "0 5"] [-e "3 4"] --config=config/config-DUT_ID-gear_ID.cfg -o batch1 1001-hit.slcio [ 1002-hit.slcio 1003-hit.slcio ]
 # -o batch1 - output filename ( batch1-align-db.slcio and batch1-align-histo.root)
 # 1001-hit.slcio - input filename 
 # optional files: 1002-hit.slcio 1003-hit.slcio
 # optional parameters:
 # -f "0 5": fix planes 0 and 5     
 # -e "3 4": exclude planes 3 and 4
 # these two parameters are identical to ExcludePlanes and FixedPlanes  in the
 # config.cfg file
@endcode 

<li> Fitter - based on the aligned clusters position one can reconstruct tracks
from the beam particles and interpolate (extrapolate) the track to a DUT
surface. 
@code
 ./submit-fitter.py  --config=config/config-DUT_ID-gear_ID.cfg -o batch1 -a  batch1-align-db.slcio 1001-hit.slcio [ 1002-hit.slcio 1003-hit.slcio ] 
 # -o batch1 - outputfilename (batch1-fitter.slcio and batch1-track-histo.root)
 # -a batch1-align-db.slcio - input file (alignment constants)
 # 1001-hit.slcio - input filename (with hits) 
 # optional files: 1002-hit.slcio 1003-hit.slcio 
@endcode 
</ul>
</ul>

*/

*****************************************************************************


*****************************************************************************

/**

@page gridtools How to run python scripts on GRID. 

The following few lines of code should be rapped up in a short script (say
.load_grid.sh):

@code
 setenv INSTALL_ROOT /afs/desy.de/project/glite/UI
 # for SL4:
 source $INSTALL_ROOT/etc/profile.d/grid-env-3.1.csh 
 # for SL5:
 # source $INSTALL_ROOT/etc/profile.d/grid-env.csh 
 #
 voms-proxy-init -debug -voms ilc:/ilc/eudet-jra1 -valid        365:0
 glite-wms-job-delegate-proxy -d $USER 
 voms-proxy-info -debug -all
@endcode


Install the general ILC grid scripts:
@code
#
# change dir to the ILCSOFT root folder
# 
svn co https://svnsrv.desy.de/public/ilctools/gridtools/trunk/LCSoftGridScripts
#
# edit the config file:
vim LCSoftGridScripts/ilc-grid-config.sh
# --
# -- export SW_VER="v01-11"
# -- export SW_ARCH="sl5"
# --
@endcode

Change folder to the PYSUB folder and edit the config file:
@code
#
cd $EUTELESCOPE/HEAD/pysub/
# 
# edit the config file:
vim config/config.cfg
# --
# the following section should be corrected:
# GRID library
#
# GRIDLibraryTarball            = job_tarball_YYMMDD_v01_11.tgz
# GRIDLibraryTarballPath        = $LFC_HOME/2010/tb-cern-summer/DUT/software
# GRIDILCSoftVersion            = v01-11
# GRIDJDLTemplate               = $ILCSOFT/Eutelescope/HEAD/pysub/grid/jdl-tmp.jdl
# 
# [GRIDLibraryContent]
# EUTelescopeLib = $ILCSOFT/Eutelescope/HEAD/lib/libEutelescope.so*
# Pede           = $ILCSOFT/Eutelescope/HEAD/bin/pede
# Pede2LCIO      = $ILCSOFT/Eutelescope/HEAD/bin/pede2lcio
# Pedemerge      = $ILCSOFT/Eutelescope/HEAD/bin/pedestalmerge
# EudaqLib       = $ILCSOFT/eudaq/bin/libeudaq.so
# ILCGRIDConfig  = $ILCSOFT/LCSoftGridScripts/ilc-grid-config.sh
# ILCGRIDTestSys = $ILCSOFT/LCSoftGridScripts/ilc-grid-test-sys.sh
# ILCGRIDTestSw  = $ILCSOFT/LCSoftGridScripts/ilc-grid-test-sw.sh
# Cmsos          = $ILCSOFT/LCSoftGridScripts/cmsos.sh
# EmptyROOTFile  = $ILCSOFT/data/empty.root
# --
# --
@endcode

If all files are present rap the tarball and upload to the grid folder: 
@code
# 
./prepare-gridlib.py --config-file=config/config.cfg  --output=lfn:/grid/ilc/eudet-jra1/2010/tb-cern-autumn/DUT/software/job_tarball_YYMMDD_v00.tgz
# 
@endcode

Notice that 
@code
# the folder 
# /grid/ilc/eudet-jra1/2010/tb-cern-autumn/DUT/software/ 
# should exist
# 
# the file tag YYMMDD_v00 should be also meaningfull 
#
@endcode

@code
Some abbreviations
==================
LFN  - logical file name
GUID - Globally Unique Identifier 
URL  - Uniform Resource Locator
SURL - Storage URL
TURL - Transfer (Transport) URL
VO   - virtual organization
SE   - storage element
LCG  - LHC Computing Grid
LFC  - LHC File Catalog
SRM  - Storage Resource Manager 


Get Grid UI middleware on your SL3/4 machine:
============================================
# source /afs/desy.de/group/grid/UI/GLITE/etc/profile.d/grid_env.sh

Set location of catalogue:
=========================
# export LFC_HOST=grid-lfc.desy.de

Proxy:
======
# voms-proxy-init -debug -voms ilc:/ilc -valid 365:0
  
# glite-wms-job-delegate-proxy -d $USER 

# voms-proxy-info -debug -all

List entries in file catalogue:
================================
# lfc-ls -l /grid/ilc/eudet-jra1/2011/tb-desy-spring/

Copying the file to your local system from the Grid:
==================================================
# lcg-cp -v --vo ilc lfn:/grid/ilc/eudet-jra1/2011/tb-desy-spring/lcio-raw/run000608.slcio file:run000608.slcio

Listing the directory:
======================
# lfc-ls -R /grid/.../directoryname

Creating a directory using the LFC file catalogue:
=================================================
# lfc-mkdir /grid/.../directoryname

Finding all sites which support ilc:
===================================
# lcg-infosites --vo ilc all

Copy and register a file:
===========================
# lcg-cr -v --vo ilc -t 1800 -d srm://dcache-se-desy.desy.de/pnfs/desy.de/ilc/../filename -l lfn:/grid/ilc/../filename file:filename

Replicating the file to another site (here globe-door.ifh.de):
==============================================================
# lcg-rep -v --vo ilc lfn:/grid/ilc/test/testag1 -d globe-door.ifh.de

List replicas of the logical file name (LFN):
============================================
# lcg-lr -v --vo ilc lfn:/grid/ilc/eudet-jra1/2011/tb-desy-spring/lcio-raw/run000601.slcio

Deleting of only one replica via:
================================
# lcg-del -a -v --vo ilc srm://...../filename

Delete the file again and all it replicas via its LFN: 
(be careful, here you are deleting the file itself!!)
==========================================================
# lcg-del -a -v --vo ilc lfn:/grid/ilc/..../filename

Register files from dCache on the GRID:
======================================
# lcg-rf -v --vo ilc -l lfn:/grid/ilc/eudet-jra1/2011/tb-desy-spring/native/run000615.raw srm://dcache-se-desy.desy.de/pnfs/desy.de/ilc/eudet-jra1/2011/tb-desy-spring/native/run000615.raw

Unregister files (without deleting it in dCache):
=============================================
# lcg-uf --vo ilc GUID (see how to check GUID in the next command)

List the GUID for a given LFN or SURL:
=====================================
# lcg-lg -v --vo ilc lfn:/grid/ilc/../filename


@endcode




*/

*****************************************************************************



/**

@page cdsPage CDS calculation

CDS is a very powerful technique to reduce the noise in particle
detectors. MAPS uses CDS very extensively and even if it is based on
the difference between two following sampling of the same pixel
signal, it is worth to explain how CDS is calculated in a test beam
setup. 

@section cds3frame Calculating CDS in RAW3 mode.

When working in RAW3 mode, the EUDRB DAQ producer is streaming out for
each triggered event, three following full frames, being the trigger
accepted by the EUDRB during the second one. Oversimplifying the
situation let us start considering the detector linear. Each frame
contains all the readout pixels chronologically sorted, starting from
the first one.
<br><br>
@image html cdsraw3.png "CDS algorithm with RAW 3".
<br><br>
The trigger is arriving sometime during the readout of the second
frame. The arrow in the figure is showing which pixel is readout when
the trigger is accepted by the DAQ and <b>not the hit pixel</b>. The position
of the arrow is dividing the second frame in two parts:
@li the preceding one (<b>region 1</b>) made by pixels that are
already readout at the trigger time,
@li the following part (<b>region 2</b>) made by pixels that are readout after the trigger.

A priori, we do not know whether the particle is passing through the
detector and consequently we have to analyze both region 1 and 2
separately. If it is on region 1, the signal will
pop up only at the next reading, so during the first part of the third
frame (yellow part in the picture). Instead, if it is on region 2,
the particle signal is going to be sampled and then as reference
signal the second part of the first frame should be used (cyan part in
the picture).
<br>
The EUDRB is making available the trigger arrival position. To simplify the
calculation, the EUDRB producer via the EUDRBDecoder::GetArrays is
providing four vectors with one component per pixel.
@li @c "m_adc[0]", @c "m_adc[1]", @c "m_adc[2]" contain the reading of the
first, second and third frames respectively.
@li @c "m_pivot" is an array of boolean, that is 0 till the trigger
arrival and then it is 1 till the end. 

*/

/**
@page minimal_config Minimal configuration
\include minimal.cfg
*/

/**
@page complete_config Complete configuration
\include complete_20100610.cfg
*/
