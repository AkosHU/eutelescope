/*
 * This source code is part of the Eutelescope package of Marlin.
 * You are free to use this source files for your own development as
 * long as it stays in a public research context. You are not
 * allowed to use it for commercial purpose. You must put this
 * header with author names in all development based on this file.
 *
 */
#ifndef EUTELTRACKERDATAINTERFACERIMPL_HCC
#define EUTELTRACKERDATAINTERFACERIMPL_HCC

#include <stdexcept>
namespace eutelescope {

//! The implementation of EUTelTrackerDataInterfacer. 
/*! Contains all the implementations as well as the template specific code */
template<class PixelType>
class EUTelTrackerDataInterfacerImpl : public EUTelTrackerDataInterfacer {
  private:

  public:
	//! Default constructor
	EUTelTrackerDataInterfacerImpl(IMPL::TrackerDataImpl* data);

	//! Add a pixel
	/*!
	 *  This method is used to add to the current TrackerDataImpl a
	 * new pixel with all the pieces of information.
	 */
    
	virtual void push_back(EUTelBaseSparsePixel const & pixel) override {
	this->push_back(dynamic_cast<PixelType const &>(pixel));
	}

	std::vector<PixelType> const & getPixels() const {
		return _pixelVec;
	} 

  protected:
	//! Internal method to fill the local copy of all the pixels
	/*! Only to be used in this class */
	void fillPixelVec();

	void validateRefVec() const override {
		_refVec.clear();
		_refVec.reserve(_pixelVec.size());
		for(auto& pixel: _pixelVec) {
			_refVec.emplace_back(pixel);
		}
		_refVecValid = true;
	}

  private:
	void pushChargeValues(PixelType const & pixel);

	//! This is the TrackerDataImpl
	/*! This is the object where the sparse data information are
	 * collected all together.
	 */
	IMPL::TrackerDataImpl* _trackerData;

	//! Number of elements in the sparse pixel
	/*! This value is initialized in the constructor and taken from
	 * the template class.
	 */
	size_t _nElement;

	//! Sparse pixel type
	/*! This enumerator value is set in the constructor and taken from
	 * the template class.
	 */
	SparsePixelType _type;

	//! Local copy of the pixels
	std::vector<PixelType > _pixelVec;

  public:
	auto begin() const -> decltype(this->_pixelVec.begin()) {
		return _pixelVec.begin();
	}

	auto end() const -> decltype(this->_pixelVec.end()) {
		return _pixelVec.end();
	}

	virtual auto at(size_t i) const -> decltype(_pixelVec.at(i)) final override {
		return _pixelVec.at(i);
	}

	virtual auto operator[](size_t i) const -> decltype(this->_pixelVec.operator[](i)) final override {
		return _pixelVec.operator[](i);
	}

	void push_back(PixelType const & pixel) {
		_pixelVec.push_back(pixel);
		this->pushChargeValues(pixel);
		_refVecValid = false;
	}   

	template <typename ...Par>
	void emplace_back(Par&&... par) { 
		_pixelVec.emplace_back(std::forward<Par>(par)...);
		this->pushChargeValues(_pixelVec.back());
	}
};

	//! Template specialization for the pushChargeValues method
	template<>
	inline void EUTelTrackerDataInterfacerImpl<EUTelSimpleSparsePixel>::pushChargeValues(EUTelSimpleSparsePixel const & pixel){
		_trackerData->chargeValues().push_back( static_cast<float> (pixel.getXCoord()) );
		_trackerData->chargeValues().push_back( static_cast<float> (pixel.getYCoord()) );
		_trackerData->chargeValues().push_back( static_cast<float> (pixel.getSignal()) );
	}

	template<>
	inline void EUTelTrackerDataInterfacerImpl<EUTelGenericSparsePixel>::pushChargeValues(EUTelGenericSparsePixel const & pixel){
		//add values to lcio charge vector
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getXCoord()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getYCoord()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getSignal()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getTime()) );
	}

	template<>
	inline void EUTelTrackerDataInterfacerImpl<EUTelGeometricPixel>::pushChargeValues(EUTelGeometricPixel const & pixel){
		//add values to lcio charge vector
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getXCoord()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getYCoord()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getSignal()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getTime()) );

		_trackerData->chargeValues().push_back( pixel.getPosX() );
		_trackerData->chargeValues().push_back( pixel.getPosY() );
		_trackerData->chargeValues().push_back( pixel.getBoundaryX() );
		_trackerData->chargeValues().push_back( pixel.getBoundaryY() );
	}

	template<>
	inline void EUTelTrackerDataInterfacerImpl<EUTelMuPixel>::pushChargeValues(EUTelMuPixel const & pixel){
		//add values to lcio charge vector
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getXCoord()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getYCoord()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getSignal()) );
		_trackerData->chargeValues().push_back( static_cast<float>(pixel.getTime()) );
		_trackerData->chargeValues().push_back(	static_cast<float>(pixel.getHitTime()) );
		_trackerData->chargeValues().push_back(	static_cast<float>(static_cast<long
		long unsigned>(pixel.getFrameTime() )  & 0xFFFFFFFF ) );
		_trackerData->chargeValues().push_back(	static_cast<float>(static_cast<long
		long unsigned>(pixel.getFrameTime() ) >> 32 ) );
	}

	//! Template specialization for the fillPixelVec method
	template<>
	inline void EUTelTrackerDataInterfacerImpl<EUTelSimpleSparsePixel>::fillPixelVec() {
		for ( size_t index = 0 ; index < _trackerData->getChargeValues().size() ; index += 3 ){
			_pixelVec.emplace_back( static_cast<short>(_trackerData->getChargeValues()[ index ]),
						static_cast<short>(_trackerData->getChargeValues()[ index + 1 ]),
						static_cast<float>(_trackerData->getChargeValues()[ index + 2 ]) 
						);
		}
	}

	template<>
	inline void EUTelTrackerDataInterfacerImpl< EUTelGenericSparsePixel>::fillPixelVec() {
		for( size_t index = 0 ; index < _trackerData->getChargeValues().size() ; index += 4 ) {
			_pixelVec.emplace_back(	static_cast<short>(_trackerData->getChargeValues()[ index ] ),
						static_cast<short>(_trackerData->getChargeValues()[ index + 1 ]),
						static_cast<float>(_trackerData->getChargeValues()[ index + 2 ]),
						static_cast<short>(_trackerData->getChargeValues()[ index + 3 ])
						);
		}
	}

	template<>
	inline void EUTelTrackerDataInterfacerImpl< EUTelGeometricPixel>::fillPixelVec() {
		for( size_t index = 0 ; index < _trackerData->getChargeValues().size() ; index += 8 ) {
			_pixelVec.emplace_back(	static_cast<short>(_trackerData->getChargeValues()[ index ] ),
						static_cast<short>(_trackerData->getChargeValues()[ index + 1 ]),
						static_cast<float>(_trackerData->getChargeValues()[ index + 2 ]),
						static_cast<short>(_trackerData->getChargeValues()[ index + 3 ]),
						_trackerData->getChargeValues()[ index + 4 ],
						_trackerData->getChargeValues()[ index + 5 ],
						_trackerData->getChargeValues()[ index + 6 ],
						_trackerData->getChargeValues()[ index + 7 ]
						);
		}
	}

	template<>
	inline void EUTelTrackerDataInterfacerImpl< EUTelMuPixel>::fillPixelVec() {
		for( unsigned int index = 0 ; index < _trackerData->getChargeValues().size() ; index += 7 ) {
			_pixelVec.emplace_back(	static_cast<short>(_trackerData->getChargeValues()[ index ] ),
						static_cast<short>(_trackerData->getChargeValues()[ index + 1 ]),
						static_cast<float>(_trackerData->getChargeValues()[ index + 2 ]),
						static_cast<short>(_trackerData->getChargeValues()[ index + 3 ]),
						static_cast<short>(_trackerData->getChargeValues()[ index + 4 ]),
						static_cast<long long unsigned>(_trackerData->getChargeValues()[index + 5]) |
						static_cast<long long unsigned>(_trackerData->getChargeValues()[index+ 6]) << 32 
						);
		}
	}
} //namespace
#endif
